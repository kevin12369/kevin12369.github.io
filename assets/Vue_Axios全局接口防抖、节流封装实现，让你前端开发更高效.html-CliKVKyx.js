import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,c as l,o as i,a as s,e as p,b as a,d as t}from"./app-Bq8DujjQ.js";const u={},r={href:"https://juejin.cn/post/7225133152490160187",target:"_blank",rel:"noopener noreferrer"},d={href:"https://github.com/mqyqingfeng/Blog/issues/3",target:"_blank",rel:"noopener noreferrer"},k={href:"https://juejin.cn/post/6844903989088092174",target:"_blank",rel:"noopener noreferrer"},m={href:"https://juejin.cn/post/6844903858636849159",target:"_blank",rel:"noopener noreferrer"},v={href:"https://zhuanlan.zhihu.com/p/33058983",target:"_blank",rel:"noopener noreferrer"},b={href:"https://juejin.cn/post/6844903657264136200",target:"_blank",rel:"noopener noreferrer"},y={href:"https://es6.ruanyifeng.com/#docs/promise",target:"_blank",rel:"noopener noreferrer"},f={href:"https://juejin.cn/post/6844903607968481287",target:"_blank",rel:"noopener noreferrer"},w={href:"https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g",target:"_blank",rel:"noopener noreferrer"},h={href:"https://juejin.cn/post/7016593221815910408",target:"_blank",rel:"noopener noreferrer"},g={href:"https://juejin.cn/post/7061588533214969892",target:"_blank",rel:"noopener noreferrer"};function j(x,n){const e=c("ExternalLinkIcon");return i(),l("div",null,[n[22]||(n[22]=s("h1",{id:"文章来源",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#文章来源","aria-hidden":"true"},"#"),a(" 文章来源")],-1)),s("p",null,[s("a",r,[n[0]||(n[0]=a("Vue + Axios全局接口防抖、节流封装实现，让你前端开发更高效",-1)),t(e)])]),n[23]||(n[23]=p(`<h2 id="js-的数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#js-的数据类型有哪些" aria-hidden="true">#</a> JS 的数据类型有哪些？</h2><ul><li>基本数据类型（值类型）：Number、String、Boolean、Null、Undefined、Symbol、BigInt。保存在栈内存中。</li><li>复杂数据类型（引用类型）：Object、Function、Array、RegExp、Date 基本包装类型及单体内置对象（Global、Math）等。</li></ul><p><strong>基本数据类型保存在栈里面，可以直接访问它的值；引用数据类型保存在堆里面，栈里面保存的时地址，通过栈里面的地址去访问堆里面的值。</strong></p><h2 id="null-和-undefined-的区别" tabindex="-1"><a class="header-anchor" href="#null-和-undefined-的区别" aria-hidden="true">#</a> null 和 undefined 的区别？</h2><ul><li><code>null</code>表示一个对象被定义了，值为“空值”。用法： <ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul></li><li><code>undefined</code>表示不存在这个值。就是此处应该有一个值，但是还没有定义，当尝试读取时就会返回 undefined。用法： <ul><li>函数没有返回值时，默认返回 undefined。</li><li>变量已声明，没有赋值时，为 undefined。</li><li>对象中没有赋值的属性，该属性的值为 undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li></ul></li></ul><p><strong>如何判断 JS 的数据类型？</strong></p><ol><li>typeof <ul><li><code>typeof</code>可以区分除了<code>Null</code>类型以外的其他基本数据类型，以及从对象类型中识别出函数（function）。</li><li>其返回值有：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code>、<code>symbol</code>、<code>bigint</code>、<code>function</code>、<code>object</code>。</li><li>其中，<code>typeof null</code>返回<code>“object”</code></li><li>如果要识别<code>null</code>，可直接使用<code>===</code>全等运算符来判断。</li></ul></li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// &#39;number&#39;</span>
<span class="token keyword">typeof</span> <span class="token string">&#39;1&#39;</span> <span class="token comment">// &#39;string&#39;</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment">// &#39;boolean&#39;</span>
<span class="token keyword">typeof</span> <span class="token keyword">undefined</span> <span class="token comment">// &#39;undefined&#39;</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#39;symbol&#39;</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token comment">// &#39;object&#39;</span>
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// &#39;object&#39;</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// &#39;object&#39;</span>
<span class="token keyword">typeof</span> console <span class="token comment">// &#39;object&#39;</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment">// &#39;function&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>instanceof <ul><li><code>instanceof</code>一般时用来判断引用数据类型，但不能正确判断基本数据类型，根据在原型链中查找判断当前数据的原型对象是否存在返回布尔类型。</li></ul></li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token boolean">true</span> <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token string">&#39;str&#39;</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">let</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
date instance <span class="token keyword">of</span> Date<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>Object.prototype.toString</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toSrting</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Object]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 结果同上，加上call也可以</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Numbar]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object String]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Boolean]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Function]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Null]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Undefined]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">123</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object RegExp]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Date]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Array]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span> <span class="token comment">// &quot;[object HTMLDocument]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span> <span class="token comment">// &quot;[object Window]&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><p>Array.isArray</p><ul><li><code>Array.isArray(value)</code>可以判断 value 是否为数组</li></ul></li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别" aria-hidden="true">#</a> == 和 === 的区别？</h2><ul><li><p>==：两个等号称为等值符，当等号两边的值为相同类型时，比较值是否为相同，类型不同时会发生乐星的自动转换，转换为相同的类型后再做比较。</p></li><li><p>===：三个等号称为等同符，当等号两边的值为相同类型时，直接比较等号两边的值，值相同则返回 true；若等号两边值的类型不同时直接返回 false。也就是三个等号既要判断类型也要判断值是否相等。</p></li></ul><h2 id="如何遍历对象的属性" tabindex="-1"><a class="header-anchor" href="#如何遍历对象的属性" aria-hidden="true">#</a> 如何遍历对象的属性？</h2><ul><li>遍历自身 <strong>可枚举的属性（可枚举，非继承属性）</strong>：<code>Object.keys()</code>方法，该方法会返回一个由给定对象的自身可枚举属性组成的数组。</li><li>遍历自身的 <strong>所有属性（可枚举、不可枚举、非集成属性）</strong>：<code>Object.getOwnPropertyNames()</code>方法，该方法会返回一个由指定对象的所有自身属性组成的数组。</li><li>遍历 <strong>可枚举的自身属性和继承属性</strong>：<code>for ... in ...</code></li></ul><h2 id="如何判断两个对象是否相等" tabindex="-1"><a class="header-anchor" href="#如何判断两个对象是否相等" aria-hidden="true">#</a> 如何判断两个对象是否相等？</h2><ol><li><p>Object,is(obj1,obj2),判断两个对象都引用地址是否一致，true 则一致，false 则不一致。</p></li><li><p>判断两个对象内容是否一致，思路是遍历对象的所有键名和键值是否都一致</p><p>① 判断两个对象是都指向同一内存</p><p>② 使用<code>Object.getOwnPropertyNames</code>获取对象所有键名数组</p><p>③ 判断两个对象的键名数组是否相等</p><p>④ 遍历键名，判断键值是否都相等</p></li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 函数实现</span>
<span class="token keyword">function</span> <span class="token function">isObjectValueEqual</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断两个对象是否指向同一内存，若是则返回true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token comment">// 获取两个对象的键名数组</span>
  <span class="token keyword">let</span> aProps <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">let</span> bProps <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token comment">// 判断两个键名数组的长度是否一致，不一致则返回false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>aProps<span class="token punctuation">.</span>length <span class="token operator">!==</span> bProps<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token comment">// 遍历对象的键值</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断 a 的键名，在 b 中是否存在，若不存在则返回false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断 a 的键值是否为对象，若是则需要递归</span>
      <span class="token comment">// 若不是，直接判断键值是否相等，若不等则返回false</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObjectValueEqual</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">!==</span> b<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="强制类型转换和隐式类型转换有哪些" tabindex="-1"><a class="header-anchor" href="#强制类型转换和隐式类型转换有哪些" aria-hidden="true">#</a> 强制类型转换和隐式类型转换有哪些？</h2><ul><li><p>强制：</p><p>转换成字符串：toString(),String()</p><p>转换成数字：Number(),parseInt(),parseFloat()</p><p>转换成布尔类型：Boolean()</p></li><li><p>隐式：</p><p>拼接字符串：let str = 1 + &quot;&quot;;</p></li></ul><h2 id="js-中的作用于和作用域链" tabindex="-1"><a class="header-anchor" href="#js-中的作用于和作用域链" aria-hidden="true">#</a> JS 中的作用于和作用域链？</h2><p><code>作用域</code>，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。作用域决定了代码区块中变量和其他资源的可见性。一般分为：<code>全局作用域</code>、<code>局部作用域（函数作用域）</code>、<code>块级作用域</code>。</p><ul><li>全局作用域：任何不在函数中或者是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程的任意位置访问。</li><li>局部作用域：也叫做函数作用域，如果一个变量是在函数内部声明的，它就在一个函数作用域下面。这些变量只能在函数内部访问，不能再函数以外去访问。</li><li>块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫做块级作用域。</li></ul><p>作用域链：当在 JS 中使用一个变量时，JS 引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推，直至找到该变量或是查找至全局作用域，如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。</p><p><strong>js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了</strong></p>`,28)),s("p",null,[n[2]||(n[2]=a("推荐阅读：",-1)),s("a",d,[n[1]||(n[1]=a("JavaScript 深入之词法作用域和动态作用域",-1)),t(e)])]),n[24]||(n[24]=p('<h2 id="js-的预解析" tabindex="-1"><a class="header-anchor" href="#js-的预解析" aria-hidden="true">#</a> JS 的预解析？</h2><p>JS 代码的执行是由浏览器中的 JS 解析器来执行的，JS 解析器执行 JS 代码时，分为两个过程：<code>预解析过程</code>和<code>代码执行过程</code>。预解析分为<code>变量预解析（变量提升）</code>和<code>函数预解析（函数提升</code>）；代码执行是指按顺序从上至下执行：</p><ul><li>变量提升：把变量的声明提升到当前作用域的最前面，只提升声明，不提升赋值；</li><li>函数提升：把函数的声明提升到当前作用域的最前面，只提升声明，不提升调用；</li></ul><p><strong>函数表达式的写法不存在函数提升</strong></p><p><strong>函数提升优先级高于变量提升，即函数提升在变量提升之上，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖</strong></p><h2 id="array-from-和-array-of-的使用及区别" tabindex="-1"><a class="header-anchor" href="#array-from-和-array-of-的使用及区别" aria-hidden="true">#</a> Array.from()和 Array.of()的使用及区别？</h2><p><code>Array.from()</code>：将伪数组对象或可遍历对象转换为真数组。接受三个参数：input、map、context。input：待转换的伪数组对象或可遍历对象；map：类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组；context：绑定 map 中用到的 this。</p><p><code>Array.of()</code>：将一系列值转换成数组，会创建一个包含所有传入参数的数组，而不管参数的数量与类型，解决了 <code>new Array()</code>行为不统一的问题。</p><h2 id="原型和原型链" tabindex="-1"><a class="header-anchor" href="#原型和原型链" aria-hidden="true">#</a> 原型和原型链？</h2><p>JS 是面向对象的，每个实例对象都有一个<code>__proto__</code>属性，概述想指向它的<code>原型</code>对象。该实例的构造函数有一个原型属性<code>prototype</code>，与实例的<code>__proto__</code>属性指向同一个对象。同时，原型对象的<code>constructor</code>指向构造函数本身。</p><p><a href="./images/%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B.png" title="对象原型">对象原型</a></p><p>当一个对象在查找一个属性时，自身没有就会根据<code>__proto__</code>属性向它的<code>原型</code>进行查找，如果还是没有，则向它的<code>原型</code>的<code>原型</code>继续查找，直至查到<code>Object.prototype.__proto__</code>也就是<code>null</code>，这样就形成了<code>原型链</code>。</p>',12)),s("p",null,[n[4]||(n[4]=a("推荐阅读：",-1)),s("a",k,[n[3]||(n[3]=a("轻松理解 JS 原型和原型链",-1)),t(e)])]),n[25]||(n[25]=s("h2",{id:"闭包",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#闭包","aria-hidden":"true"},"#"),a(" 闭包？")],-1)),s("p",null,[n[6]||(n[6]=a("在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。",-1)),n[7]||(n[7]=s("br",null,null,-1)),n[8]||(n[8]=a(" 闭包就是能够读取其他函数内部变量的函数。主要作用是解决变量污染问题，也可以用来延长局部变量的生命周期。",-1)),n[9]||(n[9]=s("br",null,null,-1)),n[10]||(n[10]=a(" 优点：延长局部变量的生命周期",-1)),n[11]||(n[11]=s("br",null,null,-1)),n[12]||(n[12]=a(" 缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏",-1)),n[13]||(n[13]=s("br",null,null,-1)),n[14]||(n[14]=a(" 推荐阅读：",-1)),s("a",m,[n[5]||(n[5]=a("我从来不理解 JavaScript 闭包，直到有人这样向我解释它",-1)),t(e)])]),n[26]||(n[26]=p(`<h2 id="new-操作符的实现机制" tabindex="-1"><a class="header-anchor" href="#new-操作符的实现机制" aria-hidden="true">#</a> new 操作符的实现机制？</h2><ol><li>首先创建了一个新的<code>空对象</code></li><li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象</li><li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> context<span class="token punctuation">.</span>prototype
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">context</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>argments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> res <span class="token operator">==</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">?</span> res <span class="token operator">:</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="this-的理解" tabindex="-1"><a class="header-anchor" href="#this-的理解" aria-hidden="true">#</a> this 的理解？</h2><ol><li>概念：<br><code>this</code>是 JS 的一个关键字，它是函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，<code>this</code>的值会发生变化，但有一个总的原则：<code>this指的是调用函数的那个对象</code>。</li><li>this 的指向： <ul><li>作为普通函数执行时，<code>this</code> 指向 <code>window</code>，但在严格模式下 <code>this</code> 指向 <code>undefined</code>。</li><li>函数作为对象里的方法被调用时，<code>this</code> 指向该对象。</li><li>当用<code>new</code>运算符调用构造函数时，<code>this</code>指向返回的这个对象。</li><li>箭头函数的<code>this</code>绑定看的是<code>this</code>所在函数定义函数定义在哪个对象下，就绑定哪个对象。如果存在嵌套，则<code>this</code>绑定到最近的一层对象上。</li><li><code>call()</code>、<code>apply()</code>、<code>bind()</code>是函数的三个方法，都可以显示的指定调用函数的 <code>this</code> 指向。</li></ul></li></ol><h2 id="call、apply、bind-的区别以及手写实现" tabindex="-1"><a class="header-anchor" href="#call、apply、bind-的区别以及手写实现" aria-hidden="true">#</a> call、apply、bind 的区别以及手写实现</h2><ul><li><code>call()</code>可以传递两个参数，第一个参数是指定函数内部中 <code>this</code> 的指向，第二个参数是函数调用时需要传递的参数。改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 实现call方法</span>
Function<span class="token punctuation">.</span>protoptype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断调用对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;type error&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 首先获取参数</span>
  <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token comment">// 将被调用的方法置入context的属性</span>
  <span class="token comment">// this 即为要调用的方法</span>
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token comment">// 执行要被调用的方法</span>
  res <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token comment">// 删除手动增加的属性方法</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token comment">// 执行结果返回</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>apply()</code>接受两个参数，第一个参数是 this 的指向，第二个参数是函数接受的参数，以<code>数组</code>的形式传入。改变 <code>this</code> 指向后原函数会立即执行,且此方法只是临时改变 <code>this</code> 指向一次。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 实现apply方法</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;type error&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">null</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window
  <span class="token comment">// 使用 symbol 来保证属性唯一</span>
  <span class="token comment">// 也就是保证不会重写用户自己原来定义在 context 中的同名属性</span>
  <span class="token keyword">const</span> fnSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  context<span class="token punctuation">[</span>fnSymbol<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token comment">// 执行被调用的方法</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> context<span class="token punctuation">[</span>fnSymbol<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> context<span class="token punctuation">[</span>fnSymbol<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fnSymbol<span class="token punctuation">]</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>bind()</code>方法的第一参数也是 <code>this</code> 的指向，后面窜如的也是一个参数列表（但是这个参数列表可以分多次传入）。改变 <code>this</code> 指向后不会立即执行，而是返回一个永久改变 <code>this</code> 指向的函数。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;type error&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Fn</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>共同点：改变函数执行时的上下文，简而言之就是改变函数运行时的 this 指向。<br> 不同点：</p><ul><li><p><code>call()</code>和 <code>bind()</code>第二个参数是列表形式的；<code>apply()</code>第二个参数是数组形式。</p></li><li><p><code>call()</code>和 <code>apply()</code>是立即执行；<code>bind()</code>不会立即执行而是生成一个修改 <code>this</code> 之后的新函数</p></li></ul><h2 id="箭头函数" tabindex="-1"><a class="header-anchor" href="#箭头函数" aria-hidden="true">#</a> 箭头函数？</h2><ol><li>箭头函数时定义函数一种新的方式，比普通函数定义更加方便和简单。</li><li>箭头函数不绑定 <code>this，会捕获其所在上下文的</code> <code>this</code>，作为自己的 <code>this</code>。</li><li>箭头函数不能用作构造函数，也就是说不可以使用 <code>new</code> 命令，否则会抛出错误。</li><li>箭头函数不绑定 <code>arguments</code>，取而代之用 <code>rest</code> 参数解决，同时没有 <code>super</code> 和 <code>new.target</code>。</li><li>使用 <code>call</code>,<code>apply</code>,<code>bind</code> 并不会改变箭头函数中的 <code>this</code> 指向。对箭头函数使用 <code>call</code> 或 <code>apply</code> 方法时，只会传入参数并调用函数；对箭头函数使用 <code>bind</code> 方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的 <code>this</code> 指向。</li></ol><h2 id="浅拷贝和深拷贝的实现" tabindex="-1"><a class="header-anchor" href="#浅拷贝和深拷贝的实现" aria-hidden="true">#</a> 浅拷贝和深拷贝的实现？</h2><p><code>浅拷贝</code>：如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。即浅拷贝是<code>拷贝一层</code>，深层次的引用类型则共享内存地址。常用的方法有：object.assign，扩展运算符等等</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
<span class="token comment">// 或</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a <span class="token punctuation">}</span>
<span class="token comment">// 实现一个浅拷贝</span>
<span class="token keyword">function</span> <span class="token function">shallowClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newObj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newObj
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>深拷贝</code>：开辟一个新的栈，两个对象的属性完全相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * 深拷贝
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>object<span class="token punctuation">}</span></span> <span class="token parameter">obj</span> 要拷贝的对象
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>Map<span class="token punctuation">}</span></span> <span class="token parameter">map</span> 用于存储循环引用对象的地址
 */</span>

<span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj <span class="token comment">// 如果是null或者undefined我就不进行拷贝操作</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token comment">// 可能是对象或者普通的值 如果是函数的话是不需要深拷贝</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">&#39;object&#39;</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj
  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 初始化返回的值</span>
  <span class="token comment">// 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">||</span> <span class="token class-name">Objcet</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&#39;[object aArray]&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 防止循环引用</span>
  map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保证 key 不是原型属性</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 递归调用</span>
      result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="javascript-中内存泄漏的几种情况" tabindex="-1"><a class="header-anchor" href="#javascript-中内存泄漏的几种情况" aria-hidden="true">#</a> JavaScript 中内存泄漏的几种情况？</h2><p>内存泄漏一般是指系统进程不在用到的内存，没有及时释放，造成内存资源的浪费，导致程序运行速度慢甚至西永崩溃等严重后果。</p><p>造成内存泄漏的原因有：</p><ol><li><p><code>全局变量。</code>在局部作用域中，函数执行完毕后，变量就没有存在的必要了，垃圾回收机制很快的做出判断并回收；但是对于全局变量，很难判断什么时候不用这些变量，无法正常回收。</p><ul><li>解决办法： <ul><li>尽量少使用全局变量</li><li>使用严格模式，在 js 文件头部或者函数的顶部加上<code>use strict</code>。</li></ul></li></ul></li><li><p><code>闭包引起的内存泄漏。</code>闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中，如果在使用结束后没有将局部变量清除，就可能导致内存泄漏。</p><ul><li>解决办法：将事件处理函数定义在外部，解除闭包。</li></ul></li><li><p><code>被遗忘的定时器。</code>定时器 <code>setInterval</code> 或者 <code>setTimeout</code> 不再需要使用时，且没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，就会造成内存泄漏。</p><ul><li>解决办法：当不需要定时器的时候，调用 <code>clearInterval</code> 或者 <code>clearTimeout</code> 手动清除。</li></ul></li><li><p><code>事件监听。</code>垃圾回收机制不好判断事件是否需要被解除，导致 <code>callback</code> 不能被释放，此时需要手动解除绑定。</p><ul><li>解决办法：及时使用 <code>removeEventlistener</code> 移除事件监听。</li></ul></li><li><p><code>元素引用没有清理。</code></p><ul><li>解决办法：移除元素后，手动设置元素的引用为 <code>null</code>。</li></ul></li><li><p><code>console。</code>传递给 <code>console.log</code> 的对象是不能被垃圾回收，可能会存在内存泄漏。</p><ul><li>解决办法：清除不必要的 <code>console</code>。</li></ul></li></ol><h2 id="防抖和节流的区别-以及手写实现" tabindex="-1"><a class="header-anchor" href="#防抖和节流的区别-以及手写实现" aria-hidden="true">#</a> 防抖和节流的区别，以及手写实现？</h2><p><code>防抖</code>：多次触发事件，事件处理函数只执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发，准备执行事件函数前，会等待一定的时间，在这个等待时间内，如果，如果没有再次被触发，那么就执行这个事件函数；如果又触发了，那么本次动作作废，重置等待时间，直到最终能执行为止。</p><p>主要应用场景：搜索框搜索输入，用户最后一次输入完成后，再发送请求；手机号邮箱严重输入检测。</p><p><code>节流</code>：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，切实最先被出发调用的那次。</p><p>主要是应用场景：高频点击、表单重复提交等。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * 函数类型：防抖函数
 * 函数用途：n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时
 * <span class="token keyword">@param</span> <span class="token parameter">func</span> 要被防抖的函数
 * <span class="token keyword">@param</span> <span class="token parameter">wait</span> 规定的时间
 */</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">//保持this指向</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments <span class="token comment">//拿到 event 对象</span>

    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token comment">// 清除定时器，释放内存</span>
    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 函数类型：节流函数
 * 函数用途：n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
 * <span class="token keyword">@param</span> <span class="token parameter">fn</span> 要被节流的函数
 * <span class="token keyword">@param</span> <span class="token parameter">wait</span> 规定的时间
 */</span>
<span class="token keyword">function</span> <span class="token function">throttled</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="eventloop-事件循环" tabindex="-1"><a class="header-anchor" href="#eventloop-事件循环" aria-hidden="true">#</a> EventLoop 事件循环？</h2><p>js 是单线成运行的，当遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行 执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列--<code>事件队列(Task Queue)</code>。被放入事件队列不会立即执行其回调，而是等待当前执行栈中所有任务都执行完毕，主程序处于闲置状态时，主线程会去查找事件队列中是否有任务，如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，遮掩就形成了一个无限的循环，这个过程被称为<code>事件循环(Event Loop)</code>。</p><p>实际上，异步任务之间并不相同，他们的执行优先级也有区别。一步任务分两类：<code>微任务(micro task)</code>和 <code>宏任务(macro task)</code>。</p><p>微任务包括：<code>promise</code> 的回调、node 中的 <code>process.nextTick</code>、对 Dom 变化监听的 <code>MutationObserver</code>。</p><p>宏任务包括：script 脚本的执行，setTimeout、setInterval 和 setImmediate 一类的定时事件，还有 I/O 操作，UI 渲染等。</p><p>在一个事件循环中，异步事件返回结果后会被放到一个时间队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的<code>宏任务队列</code>或者<code>微任务队列</code>中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。</p><p><strong>在当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p><p>推荐阅读：</p>`,39)),s("p",null,[s("a",v,[n[15]||(n[15]=a("详解 JavaScript 中的 Event Loop（事件循环）机制",-1)),t(e)])]),s("p",null,[s("a",b,[n[16]||(n[16]=a("微任务、宏任务与 Event-Loop",-1)),t(e)])]),n[27]||(n[27]=p('<h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise？</h2><p><code>Promise</code> 异步编程的一种解决方案。<code>Promise</code> 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 <code>pending</code>（初始状态）、<code>fulfilled</code>（成功的操作） 和 <code>rejected</code>（失败的操作），分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 fulfilled 或者 rejected 状态，并且状态一经改变，就无法再改变了。状态的改变是通过 <code>resolve()</code>和 <code>reject()</code>函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。Promise 的原型上定义了一个 <code>then()</code> 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p>推荐阅读：</p>',3)),s("p",null,[s("a",y,[n[17]||(n[17]=a("Promise 对象",-1)),t(e)])]),s("p",null,[s("a",f,[n[18]||(n[18]=a("Promise 不会？看这里！！！史上最通俗易懂的 Promise！！！",-1)),t(e)])]),s("p",null,[s("a",w,[n[19]||(n[19]=a("100 行代码实现 Promises/A+规范",-1)),t(e)])]),n[28]||(n[28]=s("p",null,"参考链接",-1)),s("p",null,[s("a",h,[n[20]||(n[20]=a("连八股文都不懂还指望在前端混下去么",-1)),t(e)])]),s("p",null,[s("a",g,[n[21]||(n[21]=a("做了一份前端面试复习计划，保熟~",-1)),t(e)])])])}const A=o(u,[["render",j],["__file","Vue_Axios全局接口防抖、节流封装实现，让你前端开发更高效.html.vue"]]);export{A as default};
