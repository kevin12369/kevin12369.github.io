const e=JSON.parse('{"key":"v-9aa58b04","path":"/frontend/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97-TypeScript%E7%AF%87.html","title":"TypeScript 常见面试题总结（2025版）","lang":"zh-CN","frontmatter":{"icon":"edit","date":"2025-01-02T00:00:00.000Z","category":["前端面试"],"sticky":false,"lastUpdated":true,"footer":"TypeScript 常见面试题总结","tag":["TypeScript面试题"],"description":"TypeScript 常见面试题总结（2025版） 2025年TypeScript面试趋势 TypeScript 成为必备技能：不再是可选项，而是前端开发的标准配置 高级类型深入：泛型、条件类型、映射类型、模板字面量类型 类型体操：复杂的类型操作和类型推导 类型安全：严格模式、类型守卫、类型断言 工程化：tsconfig配置、类型声明、类型检查优化","head":[["meta",{"property":"og:url","content":"https://www.baidu.com/frontend/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97-TypeScript%E7%AF%87.html"}],["meta",{"property":"og:site_name","content":"Kevin的博客"}],["meta",{"property":"og:title","content":"TypeScript 常见面试题总结（2025版）"}],["meta",{"property":"og:description","content":"TypeScript 常见面试题总结（2025版） 2025年TypeScript面试趋势 TypeScript 成为必备技能：不再是可选项，而是前端开发的标准配置 高级类型深入：泛型、条件类型、映射类型、模板字面量类型 类型体操：复杂的类型操作和类型推导 类型安全：严格模式、类型守卫、类型断言 工程化：tsconfig配置、类型声明、类型检查优化"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-02T07:07:11.000Z"}],["meta",{"property":"article:author","content":"Kevin"}],["meta",{"property":"article:tag","content":"TypeScript面试题"}],["meta",{"property":"article:published_time","content":"2025-01-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-02T07:07:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TypeScript 常见面试题总结（2025版）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-02T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-02T07:07:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kevin\\",\\"url\\":\\"https://www.baidu.com\\"}]}"]]},"headers":[{"level":2,"title":"2025年TypeScript面试趋势","slug":"_2025年typescript面试趋势","link":"#_2025年typescript面试趋势","children":[]},{"level":2,"title":"基础概念","slug":"基础概念","link":"#基础概念","children":[{"level":3,"title":"1. 什么是TypeScript？","slug":"_1-什么是typescript","link":"#_1-什么是typescript","children":[]},{"level":3,"title":"2. TypeScript 和 JavaScript 的区别？","slug":"_2-typescript-和-javascript-的区别","link":"#_2-typescript-和-javascript-的区别","children":[]},{"level":3,"title":"3. TypeScript 的优势？","slug":"_3-typescript-的优势","link":"#_3-typescript-的优势","children":[]}]},{"level":2,"title":"基础类型","slug":"基础类型","link":"#基础类型","children":[{"level":3,"title":"4. TypeScript 的基本类型有哪些？","slug":"_4-typescript-的基本类型有哪些","link":"#_4-typescript-的基本类型有哪些","children":[]},{"level":3,"title":"5. any 和 unknown 的区别？","slug":"_5-any-和-unknown-的区别","link":"#_5-any-和-unknown-的区别","children":[]},{"level":3,"title":"6. void 和 never 的区别？","slug":"_6-void-和-never-的区别","link":"#_6-void-和-never-的区别","children":[]}]},{"level":2,"title":"接口和类型别名","slug":"接口和类型别名","link":"#接口和类型别名","children":[{"level":3,"title":"7. 接口（Interface）和类型别名（Type Alias）的区别？","slug":"_7-接口-interface-和类型别名-type-alias-的区别","link":"#_7-接口-interface-和类型别名-type-alias-的区别","children":[]},{"level":3,"title":"8. 如何定义可选属性和只读属性？","slug":"_8-如何定义可选属性和只读属性","link":"#_8-如何定义可选属性和只读属性","children":[]}]},{"level":2,"title":"函数","slug":"函数","link":"#函数","children":[{"level":3,"title":"9. 如何定义函数类型？","slug":"_9-如何定义函数类型","link":"#_9-如何定义函数类型","children":[]},{"level":3,"title":"10. 如何定义可选参数和默认参数？","slug":"_10-如何定义可选参数和默认参数","link":"#_10-如何定义可选参数和默认参数","children":[]}]},{"level":2,"title":"泛型","slug":"泛型","link":"#泛型","children":[{"level":3,"title":"11. 什么是泛型？如何使用？","slug":"_11-什么是泛型-如何使用","link":"#_11-什么是泛型-如何使用","children":[]},{"level":3,"title":"12. 泛型约束","slug":"_12-泛型约束","link":"#_12-泛型约束","children":[]}]},{"level":2,"title":"高级类型","slug":"高级类型","link":"#高级类型","children":[{"level":3,"title":"13. 联合类型和交叉类型","slug":"_13-联合类型和交叉类型","link":"#_13-联合类型和交叉类型","children":[]},{"level":3,"title":"14. 类型守卫","slug":"_14-类型守卫","link":"#_14-类型守卫","children":[]},{"level":3,"title":"15. 条件类型","slug":"_15-条件类型","link":"#_15-条件类型","children":[]},{"level":3,"title":"16. 映射类型","slug":"_16-映射类型","link":"#_16-映射类型","children":[]},{"level":3,"title":"17. 模板字面量类型","slug":"_17-模板字面量类型","link":"#_17-模板字面量类型","children":[]}]},{"level":2,"title":"类型推断","slug":"类型推断","link":"#类型推断","children":[{"level":3,"title":"18. 什么是类型推断？","slug":"_18-什么是类型推断","link":"#_18-什么是类型推断","children":[]},{"level":3,"title":"19. 类型断言","slug":"_19-类型断言","link":"#_19-类型断言","children":[]}]},{"level":2,"title":"装饰器","slug":"装饰器","link":"#装饰器","children":[{"level":3,"title":"20. 什么是装饰器？","slug":"_20-什么是装饰器","link":"#_20-什么是装饰器","children":[]}]},{"level":2,"title":"类型声明","slug":"类型声明","link":"#类型声明","children":[{"level":3,"title":"21. 什么是类型声明文件？","slug":"_21-什么是类型声明文件","link":"#_21-什么是类型声明文件","children":[]},{"level":3,"title":"22. 如何为第三方库添加类型？","slug":"_22-如何为第三方库添加类型","link":"#_22-如何为第三方库添加类型","children":[]}]},{"level":2,"title":"配置","slug":"配置","link":"#配置","children":[{"level":3,"title":"23. tsconfig.json 常用配置","slug":"_23-tsconfig-json-常用配置","link":"#_23-tsconfig-json-常用配置","children":[]}]},{"level":2,"title":"2025年高频考点","slug":"_2025年高频考点","link":"#_2025年高频考点","children":[{"level":3,"title":"24. 类型体操","slug":"_24-类型体操","link":"#_24-类型体操","children":[]},{"level":3,"title":"25. 工具类型","slug":"_25-工具类型","link":"#_25-工具类型","children":[]},{"level":3,"title":"26. 类型推导","slug":"_26-类型推导","link":"#_26-类型推导","children":[]}]},{"level":2,"title":"最佳实践","slug":"最佳实践","link":"#最佳实践","children":[{"level":3,"title":"27. TypeScript 最佳实践","slug":"_27-typescript-最佳实践","link":"#_27-typescript-最佳实践","children":[]}]},{"level":2,"title":"常见问题","slug":"常见问题","link":"#常见问题","children":[{"level":3,"title":"28. 如何解决类型错误？","slug":"_28-如何解决类型错误","link":"#_28-如何解决类型错误","children":[]},{"level":3,"title":"29. 如何处理第三方库的类型问题？","slug":"_29-如何处理第三方库的类型问题","link":"#_29-如何处理第三方库的类型问题","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1767337631000,"updatedTime":1767337631000,"contributors":[{"name":"kevin12369","email":"491750329@qq.com","commits":1}]},"readingTime":{"minutes":11.35,"words":3404},"filePathRelative":"frontend/前端面试系列-TypeScript篇.md","localizedDate":"2025年1月2日","excerpt":"<h1> TypeScript 常见面试题总结（2025版）</h1>\\n<h2> 2025年TypeScript面试趋势</h2>\\n<ul>\\n<li><strong>TypeScript 成为必备技能</strong>：不再是可选项，而是前端开发的标准配置</li>\\n<li><strong>高级类型深入</strong>：泛型、条件类型、映射类型、模板字面量类型</li>\\n<li><strong>类型体操</strong>：复杂的类型操作和类型推导</li>\\n<li><strong>类型安全</strong>：严格模式、类型守卫、类型断言</li>\\n<li><strong>工程化</strong>：tsconfig配置、类型声明、类型检查优化</li>\\n</ul>","autoDesc":true}');export{e as data};
