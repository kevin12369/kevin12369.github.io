import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as n,o as c,a as t,e as i,b as o,d}from"./app-Bq8DujjQ.js";const p="/assets/两次请求-1-Bq1Z8HZT.png",s="/assets/两次请求-2-B5k_7yWW.png",h="/assets/CORS请求流程-C8i9oFI-.png",u={},g={href:"https://juejin.cn/post/7269952188927017015",target:"_blank",rel:"noopener noreferrer"},C={href:"https://github.com/amandakelake/blog/issues/62",target:"_blank",rel:"noopener noreferrer"},f={href:"http://www.ruanyifeng.com/blog/2016/04/cors.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82",target:"_blank",rel:"noopener noreferrer"},A={href:"https://github.com/xun082/react-cli",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/xun082/online-cooperative-edit",target:"_blank",rel:"noopener noreferrer"};function m(T,e){const r=a("ExternalLinkIcon");return c(),n("div",null,[e[6]||(e[6]=t("h1",{id:"post为什么会发送两次请求",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#post为什么会发送两次请求","aria-hidden":"true"},"#"),o(" post为什么会发送两次请求？")],-1)),e[7]||(e[7]=t("h2",{id:"post为什么会发送两次请求-1",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#post为什么会发送两次请求-1","aria-hidden":"true"},"#"),o(" post为什么会发送两次请求？")],-1)),t("p",null,[t("a",g,[e[0]||(e[0]=o("参考自掘金《京东一面：post为什么会发送两次请求？🤪🤪🤪》",-1)),d(r)])]),e[8]||(e[8]=i('<p>在前段时间的一次面试中，被问到了一个如标题这样的问题。要想好好地去回答这个问题，这里牵扯到的知识点也是比较多的。</p><p>那么接下来这篇文章我们就一点一点开始引出这个问题。</p><h2 id="同源策略" tabindex="-1"><a class="header-anchor" href="#同源策略" aria-hidden="true">#</a> 同源策略</h2><p>来浏览器中，内容是很开放的，任何资源都可以接入其中，如JavaScript文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。</p><p>但也不是说浏览器就是完全自有的，如果不加以空值，就会出现一些不可控的局面，例如会出现一些安全问题，如：</p><ul><li>跨站脚本攻击（XSS）。</li><li>SQL注入攻击。</li><li>OS命令注入攻击。</li><li>HTTP首部注入攻击。</li><li>跨站点请求伪造（CSRF）。</li><li>等等......。</li></ul><p>如果这些都没有限制的话，对于我们用户而言，是相对危险的，因此需要一些安全策略来保障我们的隐私和数据安全。</p><p>这就引出了最基础、最核心的安全策略：同源策略。</p><h3 id="什么是同源策略" tabindex="-1"><a class="header-anchor" href="#什么是同源策略" aria-hidden="true">#</a> 什么是同源策略</h3><p>同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何与另一个源的资源进行交互。</p><p>如果两个URL的协议、主机和端口都相同，我们就称这两个URL同源。</p><p>-　协议：协议是定义了数据如何在计算机内和之间进行交换的规则的系统，例如HTTP、HTTPS。<br> -　主机：是已链接到一个计算机网络的一台电子计算机或者其他设备。网络主机可以想网络上的用户或者其他节点提供信息资源、服务和应用。使用TCP、IP协议族参与网络的计算机也可称为IP主机。<br> -　端口：主机是计算机到计算机之间的通信，那么端口就是进程到进程之间的通信。</p><p>如下表给出了与URL<code>http://store.company.com:80/dir/page.html</code>的源进行对比的示例：</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><code>http://store.company.com:80/dir2/page.html</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>http://store.company.com:80/dir/inner/another.html</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>http://store.company.com:443/secure.html</code></td><td>不同源</td><td>协议不同，HTTP和HTTPS</td></tr><tr><td><code>http://store.company.com:81/dir/etc.html</code></td><td>不同源</td><td>端口不同</td></tr><tr><td><code>http://store.company.com:80/dir/other.html</code></td><td>不同源</td><td>主机不同</td></tr></tbody></table><p>同源策略主要表现在以下三个反面：DOM、Web数据和网络。</p><ul><li>DOM访问限制：同源策略限制了网页脚本（如JavaScript）访问其他源的DOM。这意味着通过脚本无法直接访问跨源页面的DOM元素、属性或方法。这是为了防止恶意网站从其他网站窃取敏感信息。</li><li>Web数据限制：同源策略也限制了从其他源加载的Web数据（例如XMLHttpRequest或Fetch API）。在同源策略下，XMLHttpRequest或Fetch请求只能发送到与当前网页具有相同源的目标。这有助于防止跨站点请求伪造（CSRF）等攻击。</li><li>网络通信限制：同源策略还限制了跨源的网络通信。浏览器会阻止从一个源发出的请求获取来自其他源的响应。这样做是为了确保只有受信任的源能够与服务器进行通信，以避免恶意行为。</li></ul><h2 id="cors" tabindex="-1"><a class="header-anchor" href="#cors" aria-hidden="true">#</a> CORS</h2><p>对于浏览器限制这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p><p>浏览器将不同域的内容隔离在不同的进程中，网络进程负责下载资源并将器送到渲染进程中，但由于跨域限制，某些资源可能被阻止加载到渲染进程。如果浏览器发现一个跨域响应包含了敏感数据，它可能会阻止脚本访问这些数据，即使网络进程已经获得了这些数据。CORB的目标是在渲染之前今早阻止恶意代码获取跨域数据。</p><blockquote><p>CORB是一种安全机制，用于防止跨域请求恶意访问跨域响应的数据。渲染进程会在CORB机制的约束下，选择性地将哪些资源送入渲染进程供页面使用。</p></blockquote><p>例如，一个网页可能通过AJAX请求从另一个域的服务器获取数据。虽然某然情况下这样的请求可能会成功，但如果浏览器检查到请求返回的数据可能包含恶意代码与同源内测了冲突，浏览器可能会阻止网页访问访问的数据，以确保用户的安全。</p><p>跨源资源共享（Cross-Origin Resource Sharing，CORS）是一种机制；允许在受控的条件下，不同源的网页能够请求和共享资源。由于浏览器的同源策略限制了跨域请求，CORS提供了一种方式来解决在Web应用中进行跨域数据交换的问题。</p><p>CORS的基本思想是，服务器在响应中提供一个标头（HTTP头），指示哪些源被允许访问资源。浏览器在发起跨域请求时会先发送一个预检请求（<strong>OPTIONS 请求</strong>）到服务器，服务器通过设置适当的CORS表头来指定是否允许跨域请求，并指定允许的请求源、方法、表头等信息。</p><h3 id="简单请求" tabindex="-1"><a class="header-anchor" href="#简单请求" aria-hidden="true">#</a> 简单请求</h3><p>不会触发CORS预检请求。这样的请求为<code>简单请求</code>。若请求满足所有下述条件，则该请求可视为<code>简单请求</code>：</p><ol><li><p>HTTP方法限制：之恶能使用GET、FEAD、POST这三种HTTP方法之一。如果请求使用了其他HTTP方法，就不再视为简单请求。</p></li><li><p>自定义标头限制：请求的HTTP标头只能是以下几种常见的标头：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code>、<code>Content-Type</code>（仅限于<code>application/x-www-form-urlencoded</code>、<code>multipart/from-data</code>、<code>text/plain</code>）。HTML头部header field字段：DRP、Download、Save-Data、Viewport-Width、Width。如果请求使用了其他标头，同样不再被视为简单请求。</p></li><li><p>请求中没有使用ReadableStream对象。</p></li><li><p>不使用自定义请求标头，请求不能包含用户自定义的标头。</p></li><li><p>请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问。</p></li></ol><h3 id="预检请求" tabindex="-1"><a class="header-anchor" href="#预检请求" aria-hidden="true">#</a> 预检请求</h3><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为<code>预检请求</code>。</p><p>需预检的请求要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。<code>预检请求</code>的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><p>例如我们再掘金上删除一条沸点：</p><figure><img src="'+p+'" alt="&#39;预检请求&#39;" tabindex="0" loading="lazy"><figcaption>预检请求</figcaption></figure><p>它首先会发起一个预检请求，预检请求的头信息包括两个特殊字段：</p><ul><li>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是POST。</li><li>Access-Control-Request-Header：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>content-type</code>，<code>x-secsdk-csrf=-token</code>。</li><li>Access-Control-Allow-Origin：在上述例子中，表示<code>https：//juejin.cn</code>可以请求数据，也可以设置为<code>*</code>符号，表示统一任意跨源请求。</li><li>Access-Control-Max-Age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面的结果中，有效期是1天（86408秒），即允许缓存该条回应1天（86408秒），在此期间，不会发送另一条预检请求。</li></ul><p>一旦服务器通过了<code>预检请求</code>，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也会有一个Access-Control-Allow-Origin头信息字段。服务器的回应，也有一个Access-Control-Allow-Origin头信息字段。</p><figure><img src="'+s+'" alt="&#39;预检请求&#39;" tabindex="0" loading="lazy"><figcaption>预检请求</figcaption></figure><p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p><h3 id="附带身份凭证的请求与通配符" tabindex="-1"><a class="header-anchor" href="#附带身份凭证的请求与通配符" aria-hidden="true">#</a> 附带身份凭证的请求与通配符</h3><p>在响应附带身份凭证的请求时：</p><ul><li>为了避免恶意网站滥用Access-Control-Allow-Origin头部字段来获取用户敏感信息，服务器在设置时不能将其值设为通配符<code>*</code>相反，应该将其设置为特定的域，例如：Access-Control-Allow-Origin：<code>https://juejin.cn</code>。通过将Access-Control-Allow-Origin设置为特定的域，服务器只允许来自指定域的请求进行跨域访问。这样可以限制快于请求的范围，避免不可信的域获取到用户敏感信息。</li><li>为了避免潜在的安全风险，服务器不能将Access-Control-Allow-Headers的值设为通配符<code>*</code>。这是因为不受限制的请求头可能被滥用。相反，应该将其设置为包含标头名称的列表，例如：Access-Control-Allow-Header：X-PINGOTHER，Content-Type。通过将Access-Control-Allow-Headers设置为明确的标头名称列表，服务器可以限制哪些自定义请求头是允许的。只有在允许的标头列表中的头部字段才能在跨域请求中被接受。</li><li>为了比秒潜在的安全风险，服务器不能将Access-Control-Allow-Methods的值设为通配符<code>*</code>。这样做将允许来自任意域的请求使用任意的HTTP方法，可能导致滥用行为的发生。相反，应该将其设置为特定的请求方法名称列表，例如：Access-Control-Allow-Methods：POST、GET。通过将Access-Control-Allow-Methods设置为明确的请求方法列表，服务器可以限制哪些方法是允许的。只有再允许的方法列表中的方法才能在跨域请求中被接收和处理。</li><li>对于携带身份凭证的请求（通常是Cookie），这是因为请求的标头中携带了Cookie信息，如果Access-Control-Allow-Origin的值为<code>*</code>，请求将会失败。而将Access-Control-Allow-Origin的值设置为<code>http://juejin.cn</code>，则请求将成功执行。</li></ul><p>另外，响应标头中也携带了Set-Cookie，尝试对Cookie进行修改。如果操作失败，将会抛出异常。</p><h2 id="为什么本地使用webpack进行dev开发时-不需要服务器端配置cors的情况下访问到线上接口" tabindex="-1"><a class="header-anchor" href="#为什么本地使用webpack进行dev开发时-不需要服务器端配置cors的情况下访问到线上接口" aria-hidden="true">#</a> 为什么本地使用webpack进行dev开发时，不需要服务器端配置CORS的情况下访问到线上接口？</h2><p>当你在本地通过Ajax或者其他方式请求线上接口时，由于浏览器的同源策略，会出现跨域的问题。但是在服务器端并不会出现这个问题。</p><p>它是通过Webpack Dev Server来实现这个功能。当你在浏览器中发送请求时，请求会先被Webpack Dev Server捕获，然后根据你的代理规则将请求转发到目标服务器，目标服务器返回的数据再经由Webpack Dev Server转发回浏览器。这样就绕过了浏览器的同源策略限制，使你能够再本地开发环境中访问线上接口。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',44)),t("p",null,[t("a",C,[e[1]||(e[1]=o("CORS简单请求+预检请求",-1)),d(r)])]),t("p",null,[t("a",f,[e[2]||(e[2]=o("跨域资源共享CORS详解",-1)),d(r)])]),t("p",null,[t("a",O,[e[3]||(e[3]=o("跨源资源共享（CORS） - HTTP | MDN (mozilla.org)",-1)),d(r)])]),e[9]||(e[9]=i('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>预检请求是在进行跨域资源共享CORS时，由浏览器自动发起的一种OPTIONS请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。</p><p>跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定服务器是否允许实际的跨域请求。</p><p>预检请求中包含了一些额外的头部信息，如Origin和Access-Control-Request-Methods等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含Access-Control-Allow-Origin等头部信息的响应，浏览器才会继续发送实际的跨域请求。</p><p>使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。</p><p>整个完整的请求流程有如下图所示：</p><figure><img src="'+h+'" alt="&#39;请求流程&#39;" tabindex="0" loading="lazy"><figcaption>请求流程</figcaption></figure><p>最后分享两个我的两个开源项目，它们分别是：</p>',8)),t("p",null,[t("a",A,[e[4]||(e[4]=o("前端脚手架create-neat",-1)),d(r)])]),t("p",null,[t("a",b,[e[5]||(e[5]=o("在线代码协同编辑器",-1)),d(r)])])])}const _=l(u,[["render",m],["__file","post为什么会发送两次请求.html.vue"]]);export{_ as default};
