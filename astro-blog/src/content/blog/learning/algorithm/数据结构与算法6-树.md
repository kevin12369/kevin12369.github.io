---
title: '错误：未检查空指针'
description: '> 树是重要的非线性数据结构，在计算机科学中有着广泛的应用'
pubDate: 2024-01-01

category: '深度学习'
tags: []
draft: false
---


> 树是重要的非线性数据结构，在计算机科学中有着广泛的应用

<!-- more -->

## 前言

树是一种分层数据结构，由节点和边组成，模拟了现实世界中的层级关系。

**核心应用**：
- **二叉搜索树**：高效的数据查找、插入、删除
- **堆**：优先队列、堆排序
- **前缀树**：字符串搜索、自动补全
- **红黑树**：平衡搜索树，用于C++ STL的map/set

在本文中，我们将深入探讨：
1. 树的基本概念和术语
2. 二叉树、二叉搜索树、平衡树
3. 树的遍历方式
4. 2025年高频面试题

## 树的基本概念

### 核心术语

```
        A        <- 根节点
       / \
      B   C      <- 内部节点
     / \   \
    D   E   F    <- 叶子节点
```

**基本术语**：
- **根节点**：树的顶端节点，没有父节点
- **叶子节点**：没有子节点的节点
- **内部节点**：除根节点和叶子节点外的节点
- **父节点**：直接连接的上级节点
- **子节点**：直接连接的下级节点
- **兄弟节点**：拥有相同父节点的节点
- **深度**：从根节点到该节点的边数
- **高度**：从该节点到最远叶子节点的边数

### 树的类型

#### 二叉树

**定义**：每个节点最多有两个子节点的树

**特点**：
- 每个节点最多有两个子节点（左子节点、右子节点）
- 第i层最多有2^(i-1)个节点
- 高度为h的二叉树最多有2^h - 1个节点

#### 二叉搜索树（BST）

**定义**：左子节点 < 父节点 < 右子节点

**特点**：
- 左子树所有节点值 < 根节点值
- 右子树所有节点值 > 根节点值
- 左右子树也都是二叉搜索树

#### 平衡树

**定义**：任意节点的两个子树的高度差不超过1

**类型**：
- AVL树：严格平衡
- 红黑树：近似平衡

## 二叉树的实现

### 节点定义

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

### 创建二叉树

```python
def create_tree(values):
    if not values:
        return None
    
    root = TreeNode(values[0])
    queue = [root]
    i = 1
    
    while queue and i < len(values):
        node = queue.pop(0)
        
        if i < len(values) and values[i] is not None:
            node.left = TreeNode(values[i])
            queue.append(node.left)
        i += 1
        
        if i < len(values) and values[i] is not None:
            node.right = TreeNode(values[i])
            queue.append(node.right)
        i += 1
    
    return root
```

## 树的遍历

### 1. 前序遍历（根-左-右）

**递归实现**：
```python
def preorder_traversal(root):
    if not root:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)
```

**迭代实现**：
```python
def preorder_traversal(root):
    if not root:
        return []
    
    stack = [root]
    result = []
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result
```

### 2. 中序遍历（左-根-右）

**递归实现**：
```python
def inorder_traversal(root):
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)
```

**迭代实现**：
```python
def inorder_traversal(root):
    stack = []
    result = []
    current = root
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        result.append(current.val)
        current = current.right
    
    return result
```

### 3. 后序遍历（左-右-根）

**递归实现**：
```python
def postorder_traversal(root):
    if not root:
        return []
    return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]
```

**迭代实现**：
```python
def postorder_traversal(root):
    if not root:
        return []
    
    stack = [root]
    result = []
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    
    return result[::-1]
```

### 4. 层序遍历（BFS）

```python
from collections import deque

def level_order(root):
    if not root:
        return []
    
    queue = deque([root])
    result = []
    
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
```

## 高频面试题

### 题目1：二叉树的最大深度

**题目描述**：
给定一个二叉树，找出其最大深度。

**示例**：
```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

#### 解题思路

**方法1：递归（DFS）**

1. 如果节点为空，深度为0
2. 否则，深度 = 1 + max(左子树深度, 右子树深度)

**方法2：迭代（BFS）**

1. 层序遍历
2. 统计层数

#### 代码实现

**Python（递归）**：
```python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

**Python（迭代）**：
```python
from collections import deque

def maxDepth(root):
    if not root:
        return 0
    
    queue = deque([root])
    depth = 0
    
    while queue:
        depth += 1
        for _ in range(len(queue)):
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return depth
```

#### 复杂度分析
- **时间复杂度**：O(n) - 访问所有节点
- **空间复杂度**：O(h) - h为树的高度

### 题目2：翻转二叉树

**题目描述**：
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

**示例**：
```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

#### 解题思路

**方法：递归**

1. 翻转左子树
2. 翻转右子树
3. 交换左右子树

#### 代码实现

**Python**：
```python
def invertTree(root):
    if not root:
        return None
    
    # 递归翻转左右子树
    left = invertTree(root.left)
    right = invertTree(root.right)
    
    # 交换左右子树
    root.left = right
    root.right = left
    
    return root
```

**JavaScript**：
```javascript
function invertTree(root) {
    if (!root) {
        return null;
    }
    
    // 递归翻转左右子树
    const left = invertTree(root.left);
    const right = invertTree(root.right);
    
    // 交换左右子树
    root.left = right;
    root.right = left;
    
    return root;
}
```

#### 复杂度分析
- **时间复杂度**：O(n) - 访问所有节点
- **空间复杂度**：O(h) - 递归栈深度

### 题目3：二叉树的层序遍历

**题目描述**：
给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。

**示例**：
```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

#### 解题思路

**方法：BFS**

1. 使用队列
2. 每次处理一层的节点
3. 将下一层节点加入队列

#### 代码实现

**Python**：
```python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
```

#### 复杂度分析
- **时间复杂度**：O(n) - 访问所有节点
- **空间复杂度**：O(n) - 队列最多存储一层节点

### 题目4：验证二叉搜索树

**题目描述**：
给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

**示例**：
```
输入：root = [2,1,3]
输出：true

输入：root = [5,1,4,null,null,3,6]
输出：false
```

#### 解题思路

**方法：中序遍历**

1. BST的中序遍历是递增的
2. 遍历过程中检查是否递增

#### 代码实现

**Python（递归）**：
```python
def isValidBST(root):
    def validate(node, low=float('-inf'), high=float('inf')):
        if not node:
            return True
        
        if node.val <= low or node.val >= high:
            return False
        
        return (validate(node.left, low, node.val) and 
                validate(node.right, node.val, high))
    
    return validate(root)
```

**Python（中序遍历）**：
```python
def isValidBST(root):
    stack = []
    prev = float('-inf')
    current = root
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        
        if current.val <= prev:
            return False
        
        prev = current.val
        current = current.right
    
    return True
```

#### 复杂度分析
- **时间复杂度**：O(n) - 访问所有节点
- **空间复杂度**：O(h) - h为树的高度

## 常见陷阱

### 1. 空指针异常

**常见错误**：
```python
# 错误：未检查空指针
def maxDepth(root):
    return 1 + max(maxDepth(root.left), maxDepth(root.right))  # root可能为None
```

**正确做法**：
```python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

### 2. 递归深度过大

**常见错误**：
```python
# 错误：树太深导致栈溢出
def deep_traversal(root):
    if not root:
        return
    deep_traversal(root.left)
    deep_traversal(root.right)
```

**正确做法**：
```python
def deep_traversal(root):
    stack = [root]
    while stack:
        node = stack.pop()
        if node:
            stack.append(node.right)
            stack.append(node.left)
```

## 实际应用

### 1. 文件系统

```python
class FileSystem:
    def __init__(self):
        self.root = TreeNode("/")
    
    def create_path(self, path, value):
        components = path.split('/')[1:]
        current = self.root
        
        for component in components[:-1]:
            if not current.left:
                return False
            current = current.left
        
        if current.left:
            return False
        
        current.left = TreeNode(components[-1])
        current.left.val = value
        return True
```

### 2. 表达式树

```python
class ExpressionTree:
    def build_expression_tree(self, postfix):
        stack = []
        
        for token in postfix:
            if token in '+-*/':
                node = TreeNode(token)
                node.right = stack.pop()
                node.left = stack.pop()
                stack.append(node)
            else:
                stack.append(TreeNode(token))
        
        return stack[0] if stack else None
    
    def evaluate(self, root):
        if not root:
            return 0
        
        if root.val not in '+-*/':
            return int(root.val)
        
        left = self.evaluate(root.left)
        right = self.evaluate(root.right)
        
        if root.val == '+':
            return left + right
        elif root.val == '-':
            return left - right
        elif root.val == '*':
            return left * right
        elif root.val == '/':
            return left // right
```

## 2025年面试趋势

### 1. 综合考察

**趋势**：
- 树 + 递归
- 树 + DFS/BFS
- 树 + 动态规划

### 2. 平衡树

**趋势**：
- AVL树操作
- 红黑树原理
- 平衡因子计算

### 3. 实际场景

**趋势**：
- 文件系统设计
- 数据库索引
- 表达式求值

## 总结

树是重要的非线性数据结构，掌握树的关键在于：

1. **理解基本概念**：根节点、叶子节点、深度、高度等
2. **掌握遍历方式**：前序、中序、后序、层序
3. **熟练递归思想**：树的问题通常可以用递归解决
4. **注意边界条件**：空树、单节点等
5. **结合实际应用**：文件系统、表达式树等

**学习建议**：
- 多画图理解树的结构
- 练习不同遍历方式
- 掌握递归和迭代实现
- 注意时间复杂度分析

**下一步**：继续学习图、排序、动态规划等高级主题。

---

**参考资料**：
- LeetCode：https://leetcode.cn/
- 《算法（第4版）》
- 《剑指Offer》