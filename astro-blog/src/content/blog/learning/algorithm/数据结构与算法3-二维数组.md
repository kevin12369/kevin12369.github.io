---
title: '行优先存储（大多数语言）'
description: '> 二维数组是处理矩阵、图像等二维数据的核心数据结构'
pubDate: 2024-01-01

category: '深度学习'
tags: []
draft: false
---


> 二维数组是处理矩阵、图像等二维数据的核心数据结构

<!-- more -->

## 前言

二维数组是一种特殊的数组结构，它将每个元素变成了一维数组，本质上仍然是连续存储的。二维数组广泛应用于：

- **矩阵运算**：线性代数、图像处理
- **游戏开发**：地图、棋盘
- **数据可视化**：表格、图表
- **机器学习**：特征矩阵、图像数据

在本文中，我们将深入探讨：
1. 二维数组的内存模型
2. 矩阵操作的核心技巧
3. 2025年高频面试题
4. 高级遍历技巧

## 二维数组的本质

### 内存布局

二维数组在内存中仍然是**连续存储**的，只是逻辑上分为多行。

```
二维数组: [[1, 2, 3, 4],
           [5, 6, 7, 8],
           [9, 10, 11, 12]]

内存布局（行优先）:
地址: 1000 1004 1008 1012 1016 1020 1024 1028 1032 1036 1040 1044
值:   [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]  [10] [11] [12]
索引: [0,0][0,1][0,2][0,3][1,0][1,1][1,2][1,3][2,0][2,1][2,2][2,3]
```

**关键点**：
- 物理上是一维连续存储
- 逻辑上是二维结构
- 通过行优先或列优先方式映射

### 访问原理

访问`matrix[i][j]`的步骤：

```python
# 行优先存储（大多数语言）
def access(matrix, i, j):
    row_size = len(matrix[0])  # 每行元素个数
    element_size = 4  # 假设每个元素4字节
    base_address = get_base_address(matrix)
    
    # 计算偏移量
    offset = (i * row_size + j) * element_size
    target_address = base_address + offset
    
    return read_memory(target_address)
```

**时间复杂度**：O(1)

## 二维数组的基本操作

### 1. 初始化

**方法1：直接初始化**
```python
# 3x4矩阵
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]
```

**方法2：使用列表推导式**
```python
# 3x4全零矩阵
matrix = [[0 for _ in range(4)] for _ in range(3)]

# 3x4单位矩阵
n = 3
identity = [[1 if i == j else 0 for j in range(n)] for i in range(n)]
```

**方法3：使用NumPy**
```python
import numpy as np

# 3x4全零矩阵
matrix = np.zeros((3, 4))

# 3x3随机矩阵
matrix = np.random.rand(3, 3)

# 3x3单位矩阵
identity = np.eye(3)
```

### 2. 遍历

**方法1：行优先遍历**
```python
for i in range(len(matrix)):
    for j in range(len(matrix[0])):
        print(matrix[i][j])
```

**方法2：列优先遍历**
```python
for j in range(len(matrix[0])):
    for i in range(len(matrix)):
        print(matrix[i][j])
```

**方法3：对角线遍历**
```python
n = len(matrix)
for i in range(n):
    print(matrix[i][i])  # 主对角线

for i in range(n):
    print(matrix[i][n - 1 - i])  # 副对角线
```

### 3. 矩阵操作

#### 矩阵加法

```python
def matrix_add(A, B):
    n, m = len(A), len(A[0])
    result = [[0 for _ in range(m)] for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            result[i][j] = A[i][j] + B[i][j]
    
    return result
```

#### 矩阵转置

```python
def transpose(matrix):
    n, m = len(matrix), len(matrix[0])
    result = [[0 for _ in range(n)] for _ in range(m)]
    
    for i in range(n):
        for j in range(m):
            result[j][i] = matrix[i][j]
    
    return result
```

#### 矩阵乘法

```python
def matrix_multiply(A, B):
    n, m, p = len(A), len(A[0]), len(B[0])
    result = [[0 for _ in range(p)] for _ in range(n)]
    
    for i in range(n):
        for j in range(p):
            for k in range(m):
                result[i][j] += A[i][k] * B[k][j]
    
    return result
```

## 高频面试题

### 题目1：旋转矩阵

**题目描述**：
给你一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

**示例**：
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

#### 解题思路

**方法1：转置 + 翻转**

1. 转置矩阵：行列互换
2. 水平翻转：每行左右对称交换

**步骤**：
```
原始矩阵:
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]

步骤1：转置
[1, 4, 7]
[2, 5, 8]
[3, 6, 9]

步骤2：水平翻转
[7, 4, 1]
[8, 5, 2]
[9, 6, 3]
```

#### 代码实现

**Python**：
```python
def rotate(matrix):
    n = len(matrix)
    
    # 转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    
    # 水平翻转
    for i in range(n):
        for j in range(n // 2):
            matrix[i][j], matrix[i][n - 1 - j] = matrix[i][n - 1 - j], matrix[i][j]
```

**JavaScript**：
```javascript
function rotate(matrix) {
    const n = matrix.length;
    
    // 转置
    for (let i = 0; i < n; i++) {
        for (let j = i; j < n; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
    
    // 水平翻转
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n / 2; j++) {
            [matrix[i][j], matrix[i][n - 1 - j]] = [matrix[i][n - 1 - j], matrix[i][j]];
        }
    }
}
```

#### 复杂度分析
- **时间复杂度**：O(n²) - 转置O(n²) + 翻转O(n²)
- **空间复杂度**：O(1) - 原地修改

### 题目2：零矩阵

**题目描述**：
编写一种算法，若 M × N 矩阵中某个元素为 0，则将其所在的行与列清零。

**示例**：
```
输入：
[
  [1, 1, 1],
  [1, 0, 1],
  [1, 1, 1]
]
输出：
[
  [1, 0, 1],
  [0, 0, 0],
  [1, 0, 1]
]
```

#### 解题思路

**方法1：使用集合记录**

1. 遍历矩阵，记录所有0所在的行和列
2. 根据记录的行和列，将对应位置置0

**方法2：原地标记（优化空间）**

1. 使用第一行和第一列作为标记
2. 额外两个变量记录第一行和第一列是否有0

#### 代码实现

**Python（方法1）**：
```python
def setZeroes(matrix):
    m, n = len(matrix), len(matrix[0])
    rows, cols = set(), set()
    
    # 记录0的位置
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 0:
                rows.add(i)
                cols.add(j)
    
    # 置零行
    for i in rows:
        for j in range(n):
            matrix[i][j] = 0
    
    # 置零列
    for j in cols:
        for i in range(m):
            matrix[i][j] = 0
```

**Python（方法2：原地标记）**：
```python
def setZeroes(matrix):
    m, n = len(matrix), len(matrix[0])
    first_row_zero = any(matrix[0][j] == 0 for j in range(n))
    first_col_zero = any(matrix[i][0] == 0 for i in range(m))
    
    # 使用第一行和第一列作为标记
    for i in range(1, m):
        for j in range(1, n):
            if matrix[i][j] == 0:
                matrix[i][0] = 0
                matrix[0][j] = 0
    
    # 根据标记置零
    for i in range(1, m):
        for j in range(1, n):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
    
    # 处理第一行和第一列
    if first_row_zero:
        for j in range(n):
            matrix[0][j] = 0
    
    if first_col_zero:
        for i in range(m):
            matrix[i][0] = 0
```

#### 复杂度分析

**方法1**：
- 时间复杂度：O(mn)
- 空间复杂度：O(m + n)

**方法2**：
- 时间复杂度：O(mn)
- 空间复杂度：O(1)

### 题目3：对角线遍历

**题目描述**：
给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

**示例**：
```
输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,4,7,5,3,6,8,9]
```

#### 解题思路

**方法1：模拟遍历**

观察对角线遍历的规律：
- 对角线索引和 i + j 为常数
- 方向交替：右上、左下、右上...

**步骤**：
1. 确定对角线数量：m + n - 1
2. 遍历每条对角线
3. 根据对角线索引确定方向
4. 收集元素

#### 代码实现

**Python**：
```python
def findDiagonalOrder(mat):
    if not mat or not mat[0]:
        return []
    
    m, n = len(mat), len(mat[0])
    result = []
    
    for d in range(m + n - 1):
        # 确定对角线的起始点和方向
        if d % 2 == 0:
            # 从下往上
            i = min(d, m - 1)
            j = d - i
            while i >= 0 and j < n:
                result.append(mat[i][j])
                i -= 1
                j += 1
        else:
            # 从上往下
            j = min(d, n - 1)
            i = d - j
            while j >= 0 and i < m:
                result.append(mat[i][j])
                i += 1
                j -= 1
    
    return result
```

**JavaScript**：
```javascript
function findDiagonalOrder(mat) {
    if (!mat || !mat[0]) return [];
    
    const m = mat.length;
    const n = mat[0].length;
    const result = [];
    
    for (let d = 0; d < m + n - 1; d++) {
        if (d % 2 === 0) {
            // 从下往上
            let i = Math.min(d, m - 1);
            let j = d - i;
            while (i >= 0 && j < n) {
                result.push(mat[i][j]);
                i--;
                j++;
            }
        } else {
            // 从上往下
            let j = Math.min(d, n - 1);
            let i = d - j;
            while (j >= 0 && i < m) {
                result.push(mat[i][j]);
                i++;
                j--;
            }
        }
    }
    
    return result;
}
```

#### 复杂度分析
- **时间复杂度**：O(mn) - 每个元素访问一次
- **空间复杂度**：O(1) - 不考虑输出数组

## 高级技巧

### 1. 螺旋矩阵

**题目**：按螺旋顺序输出矩阵元素

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    
    result = []
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    while top <= bottom and left <= right:
        # 从左到右
        for j in range(left, right + 1):
            result.append(matrix[top][j])
        top += 1
        
        # 从上到下
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        
        if top <= bottom:
            # 从右到左
            for j in range(right, left - 1, -1):
                result.append(matrix[bottom][j])
            bottom -= 1
        
        if left <= right:
            # 从下到上
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    
    return result
```

### 2. 矩阵搜索

**题目**：在每行从左到右递增、每行第一个元素大于上一行最后一个元素的矩阵中搜索目标值

```python
def searchMatrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    
    m, n = len(matrix), len(matrix[0])
    row, col = 0, n - 1
    
    while row < m and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col -= 1
        else:
            row += 1
    
    return False
```

### 3. 动态规划矩阵

**示例：最大正方形**

```python
def maximalSquare(matrix):
    if not matrix:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_side = 0
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if matrix[i - 1][j - 1] == '1':
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                max_side = max(max_side, dp[i][j])
    
    return max_side * max_side
```

## 常见陷阱

### 1. 索引越界

**常见错误**：
```python
# 错误：未检查边界
for i in range(len(matrix)):
    for j in range(len(matrix[0])):
        if i + 1 < len(matrix) and j + 1 < len(matrix[0]):
            # 处理matrix[i+1][j+1]
```

**正确做法**：
```python
m, n = len(matrix), len(matrix[0])
for i in range(m - 1):
    for j in range(n - 1):
        # 处理matrix[i+1][j+1]
```

### 2. 原地修改

**常见错误**：
```python
# 错误：原地修改导致后续操作错误
def process(matrix):
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            matrix[i][j] = modify(matrix[i][j])
            # 修改后的值可能影响后续操作
```

**正确做法**：
```python
def process(matrix):
    # 创建副本
    result = [row[:] for row in matrix]
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            result[i][j] = modify(matrix[i][j])
    return result
```

### 3. 方向混淆

**常见错误**：
```python
# 错误：混淆行和列
for i in range(len(matrix[0])):  # 应该是len(matrix)
    for j in range(len(matrix)):  # 应该是len(matrix[0])
        print(matrix[i][j])
```

## 实际应用

### 1. 图像处理

```python
# 图像灰度化
def grayscale(image):
    height, width = len(image), len(image[0])
    result = [[0 for _ in range(width)] for _ in range(height)]
    
    for i in range(height):
        for j in range(width):
            r, g, b = image[i][j]
            gray = int(0.299 * r + 0.587 * g + 0.114 * b)
            result[i][j] = gray
    
    return result
```

### 2. 游戏地图

```python
# 迷宫搜索
def solve_maze(maze, start, end):
    m, n = len(maze), len(maze[0])
    visited = [[False] * n for _ in range(m)]
    queue = [(start[0], start[1], [])]
    
    while queue:
        x, y, path = queue.pop(0)
        
        if (x, y) == end:
            return path + [(x, y)]
        
        if visited[x][y]:
            continue
        
        visited[x][y] = True
        
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == 0:
                queue.append((nx, ny, path + [(x, y)]))
    
    return None
```

### 3. 数据分析

```python
# 热力图生成
def heatmap(data, bins=10):
    import numpy as np
    
    # 将数据分箱
    x_bins = np.linspace(min(data[0]), max(data[0]), bins + 1)
    y_bins = np.linspace(min(data[1]), max(data[1]), bins + 1)
    
    # 创建热力图矩阵
    heatmap = np.zeros((bins, bins))
    
    for x, y in zip(data[0], data[1]):
        i = np.digitize(x, x_bins) - 1
        j = np.digitize(y, y_bins) - 1
        heatmap[j][i] += 1
    
    return heatmap
```

## 2025年面试趋势

### 1. 结合实际场景

**趋势**：
- 图像处理相关问题增多
- 游戏开发相关题目
- 数据分析场景

### 2. 空间优化

**趋势**：
- 更强调原地操作
- 要求O(1)空间复杂度
- 优化内存使用

### 3. 综合能力

**趋势**：
- 结合多种算法思想
- 动态规划 + 矩阵
- 搜索 + 矩阵

## 总结

二维数组是处理二维数据的核心工具，掌握二维数组的关键在于：

1. **理解内存模型**：知道二维数组在内存中的实际存储方式
2. **掌握遍历技巧**：行优先、列优先、对角线、螺旋等
3. **熟练矩阵操作**：转置、旋转、翻转等
4. **优化空间使用**：原地修改、标记技巧等
5. **结合实际应用**：图像处理、游戏地图等

**学习建议**：
- 多画图理解矩阵变换
- 练习不同遍历方式
- 掌握常见矩阵操作
- 结合实际场景练习

**下一步**：让我们继续学习链表，掌握动态数据结构的精髓。

---

**参考资料**：
- LeetCode：https://leetcode.cn/
- NumPy文档：https://numpy.org/
- 《剑指Offer》