---
title: '伪代码'
description: '> 数组是最基础也是最重要的数据结构，掌握数组是算法学习的起点'
pubDate: 2024-01-01

category: '未分类'
tags: []
draft: false
---


> 数组是最基础也是最重要的数据结构，掌握数组是算法学习的起点

<!-- more -->

## 前言

数组是数据结构中的基础模块，也是面试中出现频率最高的数据结构之一。据统计，LeetCode中有超过30%的题目涉及数组或字符串操作。

在本文中，我们将深入探讨：
1. 数组的核心概念和底层实现
2. 数组的基本操作及复杂度分析
3. 2025年面试中高频的数组题目
4. 双指针、滑动窗口等核心技巧
5. 数组相关的优化策略

## 数组的本质

### 集合、列表和数组

在深入数组之前，我们需要理清几个容易混淆的概念。

#### 集合（Set）

**定义**：由一个或多个确定的元素构成的整体

**特性**：
- 元素类型可以不同
- 元素之间没有顺序
- 元素唯一（无重复）

**编程语言中的体现**：
- Python的`set`
- Java的`HashSet`
- JavaScript的`Set`

#### 列表（List）

**定义**：按照一定线性顺序排列的数据项集合

**特性**：
- 元素有顺序
- 长度可变
- 元素类型可以不同

**编程语言中的体现**：
- Python的`list`
- Java的`ArrayList`
- JavaScript的`Array`

#### 数组（Array）

**定义**：列表的一种实现方式，元素在内存中连续存储

**特性**：
- 元素类型相同（大多数语言）
- 元素在内存中连续存储
- 通过索引快速访问
- 长度固定（大多数语言）

**与列表的区别**：
- **索引**：数组有索引，列表不一定
- **内存**：数组连续存储，列表不一定
- **访问速度**：数组O(1)，列表O(n)

## 数组的内存模型

### 内存布局

数组在内存中是**连续存储**的，每个元素占用相同大小的内存空间。

```
内存地址:  1000   1004   1008   1012   1016
数组元素:  [C]    [O]    [D]    [E]    [R]
索引:       0      1      2      3      4
```

**关键点**：
- 计算机记录数组首地址（索引0的地址）
- 每个元素占用固定字节数（如int占4字节）
- 通过地址计算快速访问任意元素

### 索引访问原理

访问`arr[i]`的步骤：

```python
# 伪代码
def access(arr, i):
    base_address = get_base_address(arr)  # 获取首地址
    element_size = get_element_size(arr)  # 获取元素大小
    target_address = base_address + i * element_size
    return read_memory(target_address)
```

**时间复杂度**：O(1)
- 地址计算：O(1)
- 内存访问：O(1)

## 数组的基本操作

### 1. 读取元素

**操作**：通过索引访问数组元素

**时间复杂度**：O(1)

**示例**：
```python
arr = [1, 2, 3, 4, 5]
element = arr[2]  # 访问索引2的元素
```

**原理**：
- 计算地址：首地址 + 索引 × 元素大小
- 直接读取内存

### 2. 查找元素

**操作**：在数组中查找特定元素

**时间复杂度**：O(n)

**示例**：
```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
```

**为什么是O(n)**：
- 最坏情况需要遍历整个数组
- 每次比较O(1)，共n次

**优化**：
- 如果数组有序，可以使用二分查找 O(log n)
- 使用哈希表建立索引，查找O(1)，但空间O(n)

### 3. 插入元素

#### 在末尾插入

**时间复杂度**：O(1)

```python
arr.append(6)  # 在末尾添加元素
```

**原理**：
- 计算新元素地址
- 直接写入

#### 在中间插入

**时间复杂度**：O(n)

```
原始数组: [A, B, C, D, E]
插入X到索引2:

步骤1: 腾出空间
[A, B, _, C, D, E]

步骤2: 移动元素
[A, B, X, C, D, E]
```

**代码实现**：
```python
def insert(arr, index, value):
    # 向后移动元素
    for i in range(len(arr)-1, index, -1):
        arr[i] = arr[i-1]
    # 插入新元素
    arr[index] = value
```

**为什么是O(n)**：
- 最坏情况需要移动n-1个元素
- 每次移动O(1)

### 4. 删除元素

**时间复杂度**：O(n)

```
原始数组: [A, B, C, D, E]
删除索引2的元素:

步骤1: 删除元素
[A, B, _, D, E]

步骤2: 前移元素填补空缺
[A, B, D, E, _]
```

**代码实现**：
```python
def delete(arr, index):
    # 向前移动元素
    for i in range(index, len(arr)-1):
        arr[i] = arr[i+1]
    # 删除最后一个元素
    arr.pop()
```

**为什么是O(n)**：
- 最坏情况需要移动n-1个元素
- 每次移动O(1)

## 数组操作复杂度总结

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 读取 | O(1) | O(1) | 通过索引访问 |
| 查找 | O(n) | O(1) | 线性查找 |
| 插入（末尾） | O(1) | O(1) | 动态数组可能扩容 |
| 插入（中间） | O(n) | O(1) | 需要移动元素 |
| 删除 | O(n) | O(1) | 需要移动元素 |

## 高频面试题

### 题目1：寻找数组的中心索引

**题目描述**：
给你一个整数数组`nums`，请计算数组的中心下标。数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

**示例**：
```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3。
左侧和 = 1 + 7 + 3 = 11
右侧和 = 5 + 6 = 11
```

#### 解题思路

**暴力法**：
- 遍历每个索引
- 计算左侧和与右侧和
- 比较是否相等
- 时间复杂度：O(n²)

**优化方法**：
1. 先计算总和
2. 遍历时维护左侧和
3. 右侧和 = 总和 - 左侧和 - 当前元素
4. 比较左侧和是否等于右侧和
- 时间复杂度：O(n)
- 空间复杂度：O(1)

#### 代码实现

**Python**：
```python
def pivotIndex(nums):
    total = sum(nums)
    left_sum = 0
    
    for i, num in enumerate(nums):
        if left_sum == total - left_sum - num:
            return i
        left_sum += num
    
    return -1
```

**JavaScript**：
```javascript
function pivotIndex(nums) {
    const total = nums.reduce((a, b) => a + b, 0);
    let leftSum = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (leftSum === total - leftSum - nums[i]) {
            return i;
        }
        leftSum += nums[i];
    }
    
    return -1;
}
```

**Java**：
```java
class Solution {
    public int pivotIndex(int[] nums) {
        int total = 0;
        for (int num : nums) {
            total += num;
        }
        
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (leftSum == total - leftSum - nums[i]) {
                return i;
            }
            leftSum += nums[i];
        }
        
        return -1;
    }
}
```

#### 复杂度分析
- **时间复杂度**：O(n) - 两次遍历（计算总和 + 查找中心）
- **空间复杂度**：O(1) - 只使用常数空间

### 题目2：搜索插入位置

**题目描述**：
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**要求**：时间复杂度为 O(log n)

**示例**：
```
输入：nums = [1, 3, 5, 6], target = 5
输出：2

输入：nums = [1, 3, 5, 6], target = 2
输出：1
```

#### 解题思路

**方法1：二分查找**

由于数组已排序，使用二分查找：
1. 初始化左右指针
2. 计算中间位置
3. 比较中间值与目标值
4. 调整左右指针
5. 返回左指针（插入位置）

**为什么返回左指针**：
- 循环结束时，left > right
- left指向第一个大于等于target的位置
- 即插入位置

#### 代码实现

**Python**：
```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return left
```

**JavaScript**：
```javascript
function searchInsert(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return left;
}
```

#### 复杂度分析
- **时间复杂度**：O(log n) - 二分查找
- **空间复杂度**：O(1) - 只使用常数空间

### 题目3：合并区间

**题目描述**：
以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [start(i), end(i)]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组。

**示例**：
```
输入：intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
输出：[[1, 6], [8, 10], [15, 18]]
解释：区间 [1, 3] 和 [2, 6] 重叠，将它们合并为 [1, 6]
```

#### 解题思路

**方法1：排序 + 遍历**

1. 按区间起始位置排序
2. 初始化结果数组，放入第一个区间
3. 遍历剩余区间：
   - 如果当前区间与结果数组最后一个区间重叠
     - 合并：更新结束位置为两者最大值
   - 否则
     - 添加当前区间到结果数组

**判断重叠条件**：
- 当前区间起始 <= 结果数组最后一个区间结束

#### 代码实现

**Python**：
```python
def merge(intervals):
    if not intervals:
        return []
    
    # 按起始位置排序
    intervals.sort(key=lambda x: x[0])
    
    result = [intervals[0]]
    
    for interval in intervals[1:]:
        last = result[-1]
        
        # 判断是否重叠
        if interval[0] <= last[1]:
            # 合并区间
            last[1] = max(last[1], interval[1])
        else:
            # 添加新区间
            result.append(interval)
    
    return result
```

**JavaScript**：
```javascript
function merge(intervals) {
    if (intervals.length === 0) return [];
    
    // 按起始位置排序
    intervals.sort((a, b) => a[0] - b[0]);
    
    const result = [intervals[0]];
    
    for (let i = 1; i < intervals.length; i++) {
        const last = result[result.length - 1];
        const current = intervals[i];
        
        // 判断是否重叠
        if (current[0] <= last[1]) {
            // 合并区间
            last[1] = Math.max(last[1], current[1]);
        } else {
            // 添加新区间
            result.push(current);
        }
    }
    
    return result;
}
```

#### 复杂度分析
- **时间复杂度**：O(n log n) - 排序O(n log n) + 遍历O(n)
- **空间复杂度**：O(n) - 结果数组

## 核心技巧

### 1. 双指针

双指针是处理数组问题的核心技巧，常用于：
- 排序数组中的查找
- 有序数组合并
- 数组去重

**示例：两数之和**

```python
def twoSum(nums, target):
    left, right = 0, len(nums) - 1
    
    while left < right:
        current_sum = nums[left] + nums[right]
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    
    return []
```

### 2. 滑动窗口

滑动窗口用于处理连续子数组问题：
- 固定大小窗口
- 可变大小窗口

**示例：最长不重复子串**

```python
def lengthOfLongestSubstring(s):
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### 3. 前缀和

前缀和用于快速计算区间和：
- 预处理：O(n)
- 查询：O(1)

**示例**：

```python
def prefix_sum(nums):
    # 构建前缀和数组
    prefix = [0] * (len(nums) + 1)
    for i in range(len(nums)):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # 查询区间和 [l, r]
    def range_sum(l, r):
        return prefix[r + 1] - prefix[l]
    
    return prefix, range_sum
```

### 4. 摩尔投票

摩尔投票用于寻找多数元素：
- 时间复杂度：O(n)
- 空间复杂度：O(1)

**示例**：

```python
def majorityElement(nums):
    candidate = None
    count = 0
    
    for num in nums:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1
    
    return candidate
```

## 优化策略

### 1. 空间换时间

使用额外空间降低时间复杂度：

```python
# 暴力法：O(n²)
def containsDuplicate(nums):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j]:
                return True
    return False

# 优化：使用哈希表，O(n)时间，O(n)空间
def containsDuplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False
```

### 2. 排序预处理

先排序再处理：

```python
# 无序数组查找：O(n)
def findPair(nums, target):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# 排序后双指针：O(n log n)
def findPair(nums, target):
    nums.sort()
    left, right = 0, len(nums) - 1
    
    while left < right:
        current_sum = nums[left] + nums[right]
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    
    return []
```

### 3. 原地修改

避免使用额外空间：

```python
# 使用额外数组：O(n)空间
def moveZeroes(nums):
    result = []
    for num in nums:
        if num != 0:
            result.append(num)
    result.extend([0] * (len(nums) - len(result)))
    return result

# 原地修改：O(1)空间
def moveZeroes(nums):
    insert_pos = 0
    
    # 将非零元素移到前面
    for num in nums:
        if num != 0:
            nums[insert_pos] = num
            insert_pos += 1
    
    # 填充零
    for i in range(insert_pos, len(nums)):
        nums[i] = 0
```

## 常见陷阱

### 1. 边界条件

**常见错误**：
- 忘记处理空数组
- 索引越界
- 单元素数组

**示例**：

```python
# 错误：未处理空数组
def findMax(nums):
    return max(nums)  # 空数组会报错

# 正确
def findMax(nums):
    if not nums:
        return None
    return max(nums)
```

### 2. 整数溢出

**常见错误**：
- 求和时溢出
- 索引计算溢出

**示例**：

```python
# 错误：可能溢出
def mid(left, right):
    return (left + right) // 2

# 正确：避免溢出
def mid(left, right):
    return left + (right - left) // 2
```

### 3. 修改原数组

**常见错误**：
- 修改原数组导致后续操作错误
- 未正确处理引用

**示例**：

```python
# 错误：修改原数组
def process(nums):
    nums.sort()  # 修改了原数组
    # 后续操作可能受影响

# 正确：创建副本
def process(nums):
    nums_copy = nums.copy()
    nums_copy.sort()
    # 使用副本操作
```

## 2025年面试趋势

### 1. 更注重实际应用

**趋势**：
- 减少纯算法题
- 增加场景化题目
- 结合实际业务问题

**示例**：
- 设计一个日志分析系统
- 实现一个简单的缓存
- 处理实时数据流

### 2. 多解法对比

**趋势**：
- 要求提供多种解法
- 分析每种解法的优劣
- 选择最优解

**示例**：
```python
# 解法1：暴力法 O(n²)
# 解法2：哈希表 O(n)
# 解法3：排序 + 双指针 O(n log n)
# 要求：分析三种方法的时间、空间复杂度，选择最优解
```

### 3. 代码质量要求更高

**趋势**：
- 变量命名清晰
- 适当添加注释
- 处理边界情况
- 代码风格统一

## 总结

数组是算法学习的基础，掌握数组的关键在于：

1. **理解底层**：知道数组在内存中的存储方式
2. **熟练操作**：掌握增删改查的复杂度
3. **核心技巧**：双指针、滑动窗口、前缀和等
4. **优化意识**：空间换时间、排序预处理等
5. **避免陷阱**：边界条件、整数溢出等

**学习建议**：
- 先理解原理，再刷题练习
- 每道题都要思考多种解法
- 定期复习，避免遗忘
- 结合实际场景加深理解

**下一步**：让我们继续学习二维数组，掌握矩阵相关的操作和技巧。

---

**参考资料**：
- LeetCode：https://leetcode.cn/
- 《算法图解》
- 《剑指Offer》