---
title: '前端性能优化总结（2025版）'
description: '- **Core Web Vitals 成为核心指标**：LCP、FID、CLS'
pubDate: 2024-01-01

category: '未分类'
tags: []
draft: false
---


# 前端性能优化总结（2025版）

## 2025年前端性能优化趋势

- **Core Web Vitals 成为核心指标**：LCP、FID、CLS
- **性能预算**：建立性能监控和预算机制
- **性能优化自动化**：CI/CD 集成性能测试
- **WebAssembly 应用**：提高计算密集型任务性能
- **边缘计算**：CDN 边缘渲染

## 性能指标

### 1. Core Web Vitals

**LCP (Largest Contentful Paint)**：最大内容绘制
- 衡量主要内容加载速度
- 目标：< 2.5s

**FID (First Input Delay)**：首次输入延迟
- 衡量交互响应速度
- 目标：< 100ms

**CLS (Cumulative Layout Shift)**：累积布局偏移
- 衡量视觉稳定性
- 目标：< 0.1

### 2. 其他重要指标

- **FCP (First Contentful Paint)**：首次内容绘制
- **TTI (Time to Interactive)**：可交互时间
- **TBT (Total Blocking Time)**：总阻塞时间
- **Speed Index**：速度指数

## 加载性能优化

### 3. 资源加载优化

**减少 HTTP 请求**：
- 合并 CSS、JS 文件
- 使用雪碧图或 Icon Font
- 使用 Data URI（小文件）

**使用 CDN**：
- 静态资源托管到 CDN
- 就近访问，减少延迟

**预加载和预连接**：
```html
<!-- 预连接 -->
<link rel="preconnect" href="https://cdn.example.com">
<link rel="dns-prefetch" href="https://cdn.example.com">

<!-- 预加载 -->
<link rel="preload" href="style.css" as="style">
<link rel="preload" href="script.js" as="script">

<!-- 预获取 -->
<link rel="prefetch" href="next-page.js">
```

**懒加载**：
```javascript
// 图片懒加载
<img loading="lazy" src="image.jpg" alt="...">

// 组件懒加载（React）
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// 路由懒加载（Vue）
const Home = () => import('./views/Home.vue')
```

### 4. 代码分割

**Webpack 代码分割**：
```javascript
// 动态导入
import('./module').then(module => {
  // 使用模块
});

// 路由级别代码分割
const routes = [
  {
    path: '/home',
    component: () => import('./views/Home.vue')
  }
];

// 提取公共代码
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
};
```

**Tree Shaking**：
```javascript
// ES6 模块支持 Tree Shaking
import { debounce } from 'lodash-es';

// 配置
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: false
  }
};
```

### 5. 压缩和混淆

**代码压缩**：
```javascript
// Webpack
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true
          }
        }
      })
    ]
  }
};
```

**CSS 压缩**：
```javascript
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new CssMinimizerPlugin()
    ]
  }
};
```

## 渲染性能优化

### 6. DOM 操作优化

**减少 DOM 操作**：
```javascript
// 不好的做法
for (let i = 0; i < 1000; i++) {
  document.body.innerHTML += `<div>Item ${i}</div>`;
}

// 好的做法
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
document.body.appendChild(fragment);
```

**使用虚拟 DOM**：
- React、Vue 等框架自动优化
- 减少直接 DOM 操作

### 7. CSS 优化

**避免强制同步布局**：
```javascript
// 不好的做法
function bad() {
  const width = element.offsetWidth; // 触发布局
  element.style.height = width + 'px'; // 触发布局
  const height = element.offsetHeight; // 触发布局
}

// 好的做法
function good() {
  const width = element.offsetWidth;
  const height = element.offsetHeight;
  element.style.height = width + 'px';
  element.style.width = height + 'px';
}
```

**使用 transform 和 opacity**：
```css
/* 使用 transform 实现动画 */
.element {
  transform: translateX(100px);
  transition: transform 0.3s ease;
}

/* 使用 opacity 实现淡入淡出 */
.element {
  opacity: 0;
  transition: opacity 0.3s ease;
}
```

**GPU 加速**：
```css
.element {
  transform: translateZ(0);
  will-change: transform;
}
```

### 8. JavaScript 优化

**防抖和节流**：
```javascript
// 防抖
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

// 节流
function throttle(func, wait) {
  let timer;
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        func.apply(this, args);
        timer = null;
      }, wait);
    }
  };
}
```

**使用 requestAnimationFrame**：
```javascript
function animate() {
  // 动画逻辑
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

**避免内存泄漏**：
```javascript
// 清除定时器
const timer = setInterval(() => {}, 1000);
clearInterval(timer);

// 移除事件监听
element.addEventListener('click', handler);
element.removeEventListener('click', handler);

// 清空引用
element = null;
```

## 网络优化

### 9. HTTP 缓存

**强缓存**：
```http
Cache-Control: max-age=3600
Cache-Control: no-cache
Cache-Control: no-store
```

**协商缓存**：
```http
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

### 10. HTTP/2 和 HTTP/3

**HTTP/2 优势**：
- 多路复用
- 头部压缩
- 服务器推送

**HTTP/3 优势**：
- 基于 UDP
- 更快的连接建立
- 更好的移动网络支持

### 11. Service Worker

**缓存策略**：
```javascript
// 缓存优先
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request);
    })
  );
});

// 网络优先
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request).then(response => {
      return caches.open('cache-v1').then(cache => {
        cache.put(event.request, response.clone());
        return response;
      });
    }).catch(() => caches.match(event.request))
  );
});
```

## 图片优化

### 12. 图片格式选择

**WebP**：
- 比 JPEG 小 25-35%
- 比 PNG 小 26-45%
- 支持透明和动画

**AVIF**：
- 比 WebP 小 20-50%
- 更好的压缩率

```html
<picture>
  <source srcset="image.avif" type="image/avif">
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="...">
</picture>
```

### 13. 图片懒加载

```html
<img loading="lazy" src="image.jpg" alt="...">
```

### 14. 响应式图片

```html
<img
  srcset="image-320w.jpg 320w,
          image-640w.jpg 640w,
          image-1280w.jpg 1280w"
  sizes="(max-width: 600px) 320px,
         (max-width: 1200px) 640px,
         1280px"
  src="image-1280w.jpg"
  alt="..."
>
```

## 字体优化

### 15. 字体加载优化

```html
<!-- 预加载字体 -->
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>

<!-- 字体显示策略 -->
<style>
  @font-face {
    font-family: 'MyFont';
    src: url('font.woff2') format('woff2');
    font-display: swap;
  }
</style>
```

**font-display 选项**：
- `auto`：默认行为
- `block`：短暂阻塞
- `swap`：立即显示后备字体
- `fallback`：短暂阻塞，超时后切换
- `optional`：快速显示后备字体

## 性能监控

### 16. 性能监控工具

**Lighthouse**：
```bash
npm install -g lighthouse
lighthouse https://example.com
```

**Web Vitals 库**：
```javascript
import { getCLS, getFID, getLCP } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getLCP(console.log);
```

**Performance API**：
```javascript
// 页面加载时间
window.addEventListener('load', () => {
  const perfData = performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  console.log('Page load time:', pageLoadTime);
});

// 资源加载时间
performance.getEntriesByType('resource').forEach(resource => {
  console.log(`${resource.name}: ${resource.duration}ms`);
});
```

## 2025年新技术

### 17. WebAssembly

**应用场景**：
- 图像/视频处理
- 加密解密
- 科学计算
- 游戏引擎

```javascript
// 加载 WASM 模块
WebAssembly.instantiateStreaming(fetch('module.wasm'))
  .then(results => {
    const { add } = results.instance.exports;
    console.log(add(1, 2)); // 3
  });
```

### 18. 边缘计算

**边缘渲染**：
- Cloudflare Workers
- Vercel Edge Functions
- Netlify Edge Functions

```javascript
// Cloudflare Worker
export default {
  async fetch(request) {
    const response = await fetch(request);
    return new Response(response.body, response);
  }
};
```

## 最佳实践

### 19. 性能优化清单

**加载阶段**：
- [ ] 使用 CDN
- [ ] 启用压缩
- [ ] 代码分割
- [ ] 懒加载
- [ ] 预加载关键资源

**渲染阶段**：
- [ ] 减少 DOM 操作
- [ ] 使用 CSS 动画
- [ ] 避免强制同步布局
- [ ] 使用虚拟列表

**网络阶段**：
- [ ] 启用缓存
- [ ] 使用 HTTP/2
- [ ] 优化图片
- [ ] 减少请求大小

**监控阶段**：
- [ ] 设置性能预算
- [ ] 监控 Core Web Vitals
- [ ] 定期性能审计
- [ ] 持续优化

## 常见问题

### 20. 如何诊断性能问题？

1. **使用 Chrome DevTools**：
   - Performance 面板
   - Network 面板
   - Lighthouse

2. **分析瀑布图**：
   - 识别阻塞资源
   - 优化加载顺序

3. **检查 Core Web Vitals**：
   - LCP、FID、CLS

4. **使用性能监控工具**：
   - Lighthouse
   - WebPageTest
   - GTmetrix

## 总结

前端性能优化是一个持续的过程，需要从加载、渲染、网络等多个维度进行优化。建立性能监控机制，定期审计和优化，才能确保应用始终保持良好的性能。

**优化原则**：
1. **测量优先**：先测量，再优化
2. **影响最大优先**：优先解决影响最大的问题
3. **持续优化**：性能优化是持续的过程
4. **用户体验优先**：以用户体验为中心

## 参考链接

[Web.dev - Core Web Vitals](https://web.dev/vitals/)
[MDN - Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Performance)
[Lighthouse](https://developers.google.com/web/tools/lighthouse)