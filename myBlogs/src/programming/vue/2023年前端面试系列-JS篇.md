---
icon: edit
date: 2023-03-17
category:
  - 前端面试
tag:
  - JavaScript面试题
sticky: true
lastUpdated: true
footer: JavaScript 常见面试题总结
---

# JavaScript 常见面试题总结

[参考自掘金《2023 前端面试系列-- JS 篇》](https://juejin.cn/post/7176644710847479869)

## JS 的数据类型有哪些？

- 基本数据类型（值类型）：Number、String、Boolean、Null、Undefined、Symbol、BigInt。保存在栈内存中。
- 复杂数据类型（引用类型）：Object、Function、Array、RegExp、Date 基本包装类型及单体内置对象（Global、Math）等。

**基本数据类型保存在栈里面，可以直接访问它的值；引用数据类型保存在堆里面，栈里面保存的时地址，通过栈里面的地址去访问堆里面的值。**

## null 和 undefined 的区别？

- `null`表示一个对象被定义了，值为“空值”。用法：
  - 作为函数的参数，表示该函数的参数不是对象。
  - 作为对象原型链的终点。
- `undefined`表示不存在这个值。就是此处应该有一个值，但是还没有定义，当尝试读取时就会返回 undefined。用法：
  - 函数没有返回值时，默认返回 undefined。
  - 变量已声明，没有赋值时，为 undefined。
  - 对象中没有赋值的属性，该属性的值为 undefined。
  - 调用函数时，应该提供的参数没有提供，该参数等于 undefined。

**如何判断 JS 的数据类型？**

1. typeof
   - `typeof`可以区分除了`Null`类型以外的其他基本数据类型，以及从对象类型中识别出函数（function）。
   - 其返回值有：`number`、`string`、`boolean`、`undefined`、`symbol`、`bigint`、`function`、`object`。
   - 其中，`typeof null`返回`“object”`
   - 如果要识别`null`，可直接使用`===`全等运算符来判断。

```javascript
typeof 1 // 'number'
typeof '1' // 'string'
typeof true // 'boolean'
typeof undefined // 'undefined'
typeof Symbol() // 'symbol'
typeof null // 'object'
typeof [] // 'object'
typeof {} // 'object'
typeof console // 'object'
typeof console.log // 'function'
```

2. instanceof
   - `instanceof`一般时用来判断引用数据类型，但不能正确判断基本数据类型，根据在原型链中查找判断当前数据的原型对象是否存在返回布尔类型。

```javascript
1 instanceof Number; // false
true instanceof Boolean; // false
'str' instanceof String; // false
[] instanceof Array; // true
function(){} instanceof Function; // true
{} instanceof Object; // true
let date = new Date();
date instance of Date; // true
```

3. Object.prototype.toString

```javascript
Object.prototype.toSrting({}) // "[object Object]"
Object.prototype.toString.call({}) // 结果同上，加上call也可以
Object.prototype.toString.call(1) // "[object Numbar]"
Object.prototype.toString.call('1') // "[object String]"
Object.prototype.toString.call(true) // "[object Boolean]"
Object.prototype.toString.call(function () {}) // "[object Function]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(/123/g) // "[object RegExp]"
Object.prototype.toString.call(new Date()) // "[object Date]"
Object.prototype.toString.call([]) // "[object Array]"
Object.prototype.toString.call(document) // "[object HTMLDocument]"
Object.prototype.toString.call(window) // "[object Window]"
```

4. Array.isArray

   - `Array.isArray(value)`可以判断 value 是否为数组

```javascript
Array.isArray([]) // true
Array.isArray({}) // false
Array.isArray(1) // false
Array.isArray('string') // false
Array.isArray(true) // false
```

## == 和 === 的区别？

- ==：两个等号称为等值符，当等号两边的值为相同类型时，比较值是否为相同，类型不同时会发生乐星的自动转换，转换为相同的类型后再做比较。

- ===：三个等号称为等同符，当等号两边的值为相同类型时，直接比较等号两边的值，值相同则返回 true；若等号两边值的类型不同时直接返回 false。也就是三个等号既要判断类型也要判断值是否相等。

## 如何遍历对象的属性？

- 遍历自身 **可枚举的属性（可枚举，非继承属性）**：`Object.keys()`方法，该方法会返回一个由给定对象的自身可枚举属性组成的数组。
- 遍历自身的 **所有属性（可枚举、不可枚举、非集成属性）**：`Object.getOwnPropertyNames()`方法，该方法会返回一个由指定对象的所有自身属性组成的数组。
- 遍历 **可枚举的自身属性和继承属性**：`for ... in ...`

## 如何判断两个对象是否相等？

1. Object,is(obj1,obj2),判断两个对象都引用地址是否一致，true 则一致，false 则不一致。
2. 判断两个对象内容是否一致，思路是遍历对象的所有键名和键值是否都一致

   ① 判断两个对象是都指向同一内存

   ② 使用`Object.getOwnPropertyNames`获取对象所有键名数组

   ③ 判断两个对象的键名数组是否相等

   ④ 遍历键名，判断键值是否都相等

```js
// 函数实现
function isObjectValueEqual(a, b) {
  // 判断两个对象是否指向同一内存，若是则返回true
  if (a === b) return true
  // 获取两个对象的键名数组
  let aProps = Object.getOwnPropertyNames(a)
  let bProps = Object.getOwnPropertyNames(b)
  // 判断两个键名数组的长度是否一致，不一致则返回false
  if (aProps.length !== bProps.length) return false
  // 遍历对象的键值
  for (let prop in a) {
    // 判断 a 的键名，在 b 中是否存在，若不存在则返回false
    if (b.hasOwnProperty(prop)) {
      // 判断 a 的键值是否为对象，若是则需要递归
      // 若不是，直接判断键值是否相等，若不等则返回false
      if (typeof a[prop] === 'object') {
        if (!isObjectValueEqual(a[prop], b[prop])) return false
      } else if (a[prop] !== b[prop]) {
        return false
      }
    } else {
      return false
    }
  }
  return true
}
```

## 强制类型转换和隐式类型转换有哪些？

- 强制：

  转换成字符串：toString(),String()

  转换成数字：Number(),parseInt(),parseFloat()

  转换成布尔类型：Boolean()

- 隐式：

  拼接字符串：let str = 1 + "";

## JS 中的作用于和作用域链？

`作用域`，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。作用域决定了代码区块中变量和其他资源的可见性。一般分为：`全局作用域`、`局部作用域（函数作用域）`、`块级作用域`。

- 全局作用域：任何不在函数中或者是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程的任意位置访问。
- 局部作用域：也叫做函数作用域，如果一个变量是在函数内部声明的，它就在一个函数作用域下面。这些变量只能在函数内部访问，不能再函数以外去访问。
- 块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫做块级作用域。

作用域链：当在 JS 中使用一个变量时，JS 引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推，直至找到该变量或是查找至全局作用域，如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。

**js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了**

推荐阅读：[JavaScript 深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)

## JS 的预解析？

JS 代码的执行是由浏览器中的 JS 解析器来执行的，JS 解析器执行 JS 代码时，分为两个过程：`预解析过程`和`代码执行过程`。预解析分为`变量预解析（变量提升）`和`函数预解析（函数提升`）；代码执行是指按顺序从上至下执行：

- 变量提升：把变量的声明提升到当前作用域的最前面，只提升声明，不提升赋值；
- 函数提升：把函数的声明提升到当前作用域的最前面，只提升声明，不提升调用；

**函数表达式的写法不存在函数提升**

**函数提升优先级高于变量提升，即函数提升在变量提升之上，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖**

## Array.from()和 Array.of()的使用及区别？

`Array.from()`：将伪数组对象或可遍历对象转换为真数组。接受三个参数：input、map、context。input：待转换的伪数组对象或可遍历对象；map：类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组；context：绑定 map 中用到的 this。

`Array.of()`：将一系列值转换成数组，会创建一个包含所有传入参数的数组，而不管参数的数量与类型，解决了 `new Array()`行为不统一的问题。

## 原型和原型链？

JS 是面向对象的，每个实例对象都有一个`__proto__`属性，概述想指向它的`原型`对象。该实例的构造函数有一个原型属性`prototype`，与实例的`__proto__`属性指向同一个对象。同时，原型对象的`constructor`指向构造函数本身。

[对象原型](./images/对象原型.png '对象原型')

当一个对象在查找一个属性时，自身没有就会根据`__proto__`属性向它的`原型`进行查找，如果还是没有，则向它的`原型`的`原型`继续查找，直至查到`Object.prototype.__proto__`也就是`null`，这样就形成了`原型链`。

推荐阅读：[轻松理解 JS 原型和原型链](https://juejin.cn/post/6844903989088092174)

## 闭包？

在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。
闭包就是能够读取其他函数内部变量的函数。主要作用是解决变量污染问题，也可以用来延长局部变量的生命周期。
优点：延长局部变量的生命周期
缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏
推荐阅读：[我从来不理解 JavaScript 闭包，直到有人这样向我解释它](https://juejin.cn/post/6844903858636849159)

## new 操作符的实现机制？

1. 首先创建了一个新的`空对象`
2. `设置原型`，将对象的原型设置为函数的`prototype`对象
3. 让函数的`this`指向这个对象，执行构造函数的代码（为这个对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

```js
function myNew(context) {
  const obj = new Object()
  obj.__proto__ = context.prototype
  const res = context.apply(obj, [...argments].slice(1))
  return typeof res == 'object' ? res : obj
}
```

## this 的理解？

1. 概念：
   `this`是 JS 的一个关键字，它是函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，`this`的值会发生变化，但有一个总的原则：`this指的是调用函数的那个对象`。
2. this 的指向：
   - 作为普通函数执行时，`this` 指向 `window`，但在严格模式下 `this` 指向 `undefined`。
   - 函数作为对象里的方法被调用时，`this` 指向该对象。
   - 当用`new`运算符调用构造函数时，`this`指向返回的这个对象。
   - 箭头函数的`this`绑定看的是`this`所在函数定义函数定义在哪个对象下，就绑定哪个对象。如果存在嵌套，则`this`绑定到最近的一层对象上。
   - `call()`、`apply()`、`bind()`是函数的三个方法，都可以显示的指定调用函数的 `this` 指向。

## call、apply、bind 的区别以及手写实现

- `call()`可以传递两个参数，第一个参数是指定函数内部中 `this` 的指向，第二个参数是函数调用时需要传递的参数。改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次。

```js
// 实现call方法
Function.protoptype.myCall = function (context) {
  // 判断调用对象
  if (typeof this != 'function') {
    throw new Error('type error')
  }
  // 首先获取参数
  let args = [...arguments].slice(1)
  let res = null
  // 将被调用的方法置入context的属性
  // this 即为要调用的方法
  context.fn = this
  // 执行要被调用的方法
  res = context.fn(...args)
  // 删除手动增加的属性方法
  delete context.fn
  // 执行结果返回
  return res
}
```

- `apply()`接受两个参数，第一个参数是 this 的指向，第二个参数是函数接受的参数，以`数组`的形式传入。改变 `this` 指向后原函数会立即执行,且此方法只是临时改变 `this` 指向一次。

```js
// 实现apply方法
Function.prototype.myApply = function (context) {
  if (typeof this != 'function') {
    throw new Error('type error')
  }
  let res = null
  context = context || window
  // 使用 symbol 来保证属性唯一
  // 也就是保证不会重写用户自己原来定义在 context 中的同名属性
  const fnSymbol = Symbol()
  context[fnSymbol] = this
  // 执行被调用的方法
  if (arguments[1]) {
    res = context[fnSymbol](...arguments[1])
  } else {
    res = context[fnSymbol]()
  }
  delete context[fnSymbol]
  return res
}
```

- `bind()`方法的第一参数也是 `this` 的指向，后面窜如的也是一个参数列表（但是这个参数列表可以分多次传入）。改变 `this` 指向后不会立即执行，而是返回一个永久改变 `this` 指向的函数。

```js
//
Function.prototype.myBind = function (context) {
  if (typeof this != 'function') {
    throw new Error('type error')
  }
  let args = [...arguments].slice(1)
  const fn = this
  return function Fn() {
    return fn.apply(this instanceof Fn ? this : context, args.concat(...arguments))
  }
}
```

共同点：改变函数执行时的上下文，简而言之就是改变函数运行时的 this 指向。
不同点：

- `call()`和 `bind()`第二个参数是列表形式的；`apply()`第二个参数是数组形式。

- `call()`和 `apply()`是立即执行；`bind()`不会立即执行而是生成一个修改 `this` 之后的新函数

## 箭头函数？

1. 箭头函数时定义函数一种新的方式，比普通函数定义更加方便和简单。
2. 箭头函数不绑定 `this，会捕获其所在上下文的` `this`，作为自己的 `this`。
3. 箭头函数不能用作构造函数，也就是说不可以使用 `new` 命令，否则会抛出错误。
4. 箭头函数不绑定 `arguments`，取而代之用 `rest` 参数解决，同时没有 `super` 和 `new.target`。
5. 使用 `call`,`apply`,`bind` 并不会改变箭头函数中的 `this` 指向。对箭头函数使用 `call` 或 `apply` 方法时，只会传入参数并调用函数；对箭头函数使用 `bind` 方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的 `this` 指向。
