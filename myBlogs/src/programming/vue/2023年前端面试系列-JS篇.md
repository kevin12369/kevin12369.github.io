---
icon: edit
date: 2023-03-17
category:
  - 前端面试
tag:
  - JavaScript面试题
sticky: true
lastUpdated: true
footer: JavaScript 常见面试题总结
---

# JavaScript 常见面试题总结

[参考自掘金《2023 前端面试系列-- JS 篇》](https://juejin.cn/post/7176644710847479869)

## JS 的数据类型有哪些？

- 基本数据类型（值类型）：Number、String、Boolean、Null、Undefined、Symbol、BigInt。保存在栈内存中。
- 复杂数据类型（引用类型）：Object、Function、Array、RegExp、Date 基本包装类型及单体内置对象（Global、Math）等。

**基本数据类型保存在栈里面，可以直接访问它的值；引用数据类型保存在堆里面，栈里面保存的时地址，通过栈里面的地址去访问堆里面的值。**

## null 和 undefined 的区别？

- `null`表示一个对象被定义了，值为“空值”。用法：
  - 作为函数的参数，表示该函数的参数不是对象。
  - 作为对象原型链的终点。
- `undefined`表示不存在这个值。就是此处应该有一个值，但是还没有定义，当尝试读取时就会返回 undefined。用法：
  - 函数没有返回值时，默认返回 undefined。
  - 变量已声明，没有赋值时，为 undefined。
  - 对象中没有赋值的属性，该属性的值为 undefined。
  - 调用函数时，应该提供的参数没有提供，该参数等于 undefined。

**如何判断 JS 的数据类型？**

1. typeof
   - `typeof`可以区分除了`Null`类型以外的其他基本数据类型，以及从对象类型中识别出函数（function）。
   - 其返回值有：`number`、`string`、`boolean`、`undefined`、`symbol`、`bigint`、`function`、`object`。
   - 其中，`typeof null`返回`“object”`
   - 如果要识别`null`，可直接使用`===`全等运算符来判断。

```javascript
typeof 1 // 'number'
typeof '1' // 'string'
typeof true // 'boolean'
typeof undefined // 'undefined'
typeof Symbol() // 'symbol'
typeof null // 'object'
typeof [] // 'object'
typeof {} // 'object'
typeof console // 'object'
typeof console.log // 'function'
```

2. instanceof
   - `instanceof`一般时用来判断引用数据类型，但不能正确判断基本数据类型，根据在原型链中查找判断当前数据的原型对象是否存在返回布尔类型。

```javascript
1 instanceof Number; // false
true instanceof Boolean; // false
'str' instanceof String; // false
[] instanceof Array; // true
function(){} instanceof Function; // true
{} instanceof Object; // true
let date = new Date();
date instance of Date; // true
```

3. Object.prototype.toString

```javascript
Object.prototype.toSrting({}) // "[object Object]"
Object.prototype.toString.call({}) // 结果同上，加上call也可以
Object.prototype.toString.call(1) // "[object Numbar]"
Object.prototype.toString.call('1') // "[object String]"
Object.prototype.toString.call(true) // "[object Boolean]"
Object.prototype.toString.call(function () {}) // "[object Function]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(/123/g) // "[object RegExp]"
Object.prototype.toString.call(new Date()) // "[object Date]"
Object.prototype.toString.call([]) // "[object Array]"
Object.prototype.toString.call(document) // "[object HTMLDocument]"
Object.prototype.toString.call(window) // "[object Window]"
```

4. Array.isArray

   - `Array.isArray(value)`可以判断 value 是否为数组

```javascript
Array.isArray([]) // true
Array.isArray({}) // false
Array.isArray(1) // false
Array.isArray('string') // false
Array.isArray(true) // false
```

## == 和 === 的区别？

- ==：两个等号称为等值符，当等号两边的值为相同类型时，比较值是否为相同，类型不同时会发生乐星的自动转换，转换为相同的类型后再做比较。

- ===：三个等号称为等同符，当等号两边的值为相同类型时，直接比较等号两边的值，值相同则返回 true；若等号两边值的类型不同时直接返回 false。也就是三个等号既要判断类型也要判断值是否相等。

## 如何遍历对象的属性？

- 遍历自身 **可枚举的属性（可枚举，非继承属性）**：`Object.keys()`方法，该方法会返回一个由给定对象的自身可枚举属性组成的数组。
- 遍历自身的 **所有属性（可枚举、不可枚举、非集成属性）**：`Object.getOwnPropertyNames()`方法，该方法会返回一个由指定对象的所有自身属性组成的数组。
- 遍历 **可枚举的自身属性和继承属性**：`for ... in ...`

## 如何判断两个对象是否相等？

1. Object,is(obj1,obj2),判断两个对象都引用地址是否一致，true 则一致，false 则不一致。
2. 判断两个对象内容是否一致，思路是遍历对象的所有键名和键值是否都一致

   ① 判断两个对象是都指向同一内存

   ② 使用`Object.getOwnPropertyNames`获取对象所有键名数组

   ③ 判断两个对象的键名数组是否相等

   ④ 遍历键名，判断键值是否都相等

```js
// 函数实现
function isObjectValueEqual(a, b) {
  // 判断两个对象是否指向同一内存，若是则返回true
  if (a === b) return true
  // 获取两个对象的键名数组
  let aProps = Object.getOwnPropertyNames(a)
  let bProps = Object.getOwnPropertyNames(b)
  // 判断两个键名数组的长度是否一致，不一致则返回false
  if (aProps.length !== bProps.length) return false
  // 遍历对象的键值
  for (let prop in a) {
    // 判断 a 的键名，在 b 中是否存在，若不存在则返回false
    if (b.hasOwnProperty(prop)) {
      // 判断 a 的键值是否为对象，若是则需要递归
      // 若不是，直接判断键值是否相等，若不等则返回false
      if (typeof a[prop] === 'object') {
        if (!isObjectValueEqual(a[prop], b[prop])) return false
      } else if (a[prop] !== b[prop]) {
        return false
      }
    } else {
      return false
    }
  }
  return true
}
```

## 强制类型转换和隐式类型转换有哪些？

- 强制：

  转换成字符串：toString(),String()

  转换成数字：Number(),parseInt(),parseFloat()

  转换成布尔类型：Boolean()

- 隐式：

  拼接字符串：let str = 1 + "";

## JS 中的作用于和作用域链？

`作用域`，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。作用域决定了代码区块中变量和其他资源的可见性。一般分为：`全局作用域`、`局部作用域（函数作用域）`、`块级作用域`。

- 全局作用域：任何不在函数中或者是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程的任意位置访问。
- 局部作用域：也叫做函数作用域，如果一个变量是在函数内部声明的，它就在一个函数作用域下面。这些变量只能在函数内部访问，不能再函数以外去访问。
- 块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫做块级作用域。

作用域链：当在 JS 中使用一个变量时，JS 引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推，直至找到该变量或是查找至全局作用域，如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。

**js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了**

推荐阅读：[JavaScript 深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)

## JS 的预解析

JS 代码的执行是由浏览器中的 JS 解析器来执行的，JS 解析器执行 JS 代码时，分为两个过程：`预解析过程`和`代码执行过程`。预解析分为`变量预解析（变量提升）`和`函数预解析（函数提升`）；代码执行是指按顺序从上至下执行：

- 变量提升：把变量的声明提升到当前作用域的最前面，只提升声明，不提升赋值；
- 函数提升：把函数的声明提升到当前作用域的最前面，只提升声明，不提升调用；

**函数表达式的写法不存在函数提升**

**函数提升优先级高于变量提升，即函数提升在变量提升之上，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖**

## Array.from()和 Array.of()的使用及区别？

`Array.from()`：将伪数组对象或可遍历对象转换为真数组。接受三个参数：input、map、context。input：待转换的伪数组对象或可遍历对象；map：类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组；context：绑定 map 中用到的 this。

`Array.of()`：将一系列值转换成数组，会创建一个包含所有传入参数的数组，而不管参数的数量与类型，解决了 `new Array()`行为不统一的问题。
