---
title: 数据结构与算法-二维数组
icon: page
order: 3
author: Kevin
date: 2023-12-18
category:
  - 数据结构与算法学习
tags:
  - 数据结构与算法
sticky: true
star: false
footer: 数据结构与算法-二维数组
copyright: No Copyright
---

前面的章节中，我们已经了解了 `一维数组`。然而，有时候，我们可能需要用到 `多维数组`，它更适合像表或矩阵这样更复杂的结构。

<!-- more -->

## 前言

在本文中，我们将重点围绕二维数组来解释：
1. 二维数组在内存中是如何存放的？
2. 如何运用二维数组来解决问题？

## 二维数组简介

`二维数组`是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。

![[Pasted image 20231221102232.png]]

所以二维数组本质上仍然是一个一维数组，内部的一维数组仍然从索引`0`开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。

## 示例

类似一维数组，对于一个二维数组`A = [[1, 2, 3, 4], [2, 4, 5, 6], [1, 4, 6 , 8]]`，计算机同样会在内存中申请一段**连续**的空间，并记录第一行数组的索引位置，即`A[0][0]`的内存地址，他的索引于内存地址的关系如下图所示。

![[Pasted image 20231221102947.png]]

注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值不可能为`1`。实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。

### 旋转矩阵

给你一幅由`N X M`矩阵表示的图像，其中每个像素的大小为4字节。请你设计一种算法，将图像旋转90度。
不占用额外内存空间能否做到？

示例1：

```
给定 matrix = 
[
	[1, 2, 3],
	[4, 5, 6],
	[7, 8, 9]
],

原地旋转输入矩阵，使其变为：
[
	[7, 4, 1],
	[8, 5, 2],
	[9, 6, 3]
]
```

示例2：

```
给定 matrix = 
[
	[ 5, 1, 9,11],
	[ 2, 4, 8,10],
	[13, 3, 6, 7],
	[15,14,12,16]
],

原地旋转输入矩阵，使其变为：
[
	[15,13, 2, 5],
	[14, 3, 4, 1],
	[12, 6, 8, 9],
	[16, 7,10,11]
]
```

JavaScript 写法 1:

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
	const n = matrix.length;
    // 转置矩阵
    for (let i = 0; i < n; i++) {
        // 遍历矩阵的行
        for (let j = i; j < n; j++) {
            // 交换矩阵中第i行和第j行的元素
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
    // 交换行和列
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n / 2; j++) {
            // 交换矩阵中第i行第j列和第i行第n-1-j列的值
            [matrix[i][j], matrix[i][n - 1 - j]] = [matrix[i][n - 1 - j], matrix[i][j]];
        }
    }
    return matrix;
};
```

#### 解题思路：

1. 矩阵转置：将矩阵的行和列进行互换。
2. 矩阵镜像：将矩阵的行和列的元素进行互换。

第一步：

|-|0|1|2|3|
|---|---|---|---|---|
|0|5|1|9|11|
|1|2|4|8|10|
|2|13|3|6|7|
|3|15|14|12|16|

第二步：

|-|0|1|2|3|
|---|---|---|---|---|
|0|5|2|13|15|
|1|1|4|3|14|
|2|9|8|6|12|
|3|11|10|7|16|

第三步：

|-|0|1|2|3|
|---|---|---|---|---|
|0|15|13|2|5|
|1|14|3|4|1|
|2|12|6|8|9|
|3|16|7|10|11|

### 零矩阵

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

示例1：

```
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

示例2：

```
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

JavaScript 写法1：

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {

};
```

JavaScript 写法2：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
// 暴力查找，元素少的时候效率高，元素多的时候效率低
var searchInsert = function (nums, target) {
    // 遍历数组，查找插入位置
    for (let i = 0; i < nums.length; i++) {
        // 如果target小于等于当前元素，则返回当前位置
        if (target <= nums[i]) {
            return i;
        }
    }
    // 如果target大于数组中所有元素，则返回数组长度
    return nums.length;
};
```

### 合并区间

以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [start(i), end(i)]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

示例1：

```
输入： intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
输出： [[1, 6], [8, 10], [15, 18]]
解决： 区间 [1, 3] 和 [2, 6] 重叠，将它们合并为 [1, 6]。
```

示例2：

```
输入： intervals = [[1, 4], [4, 5]]
输出： [[1, 5]]
解决： 区间 [1, 4] 和 [4, 5] 重叠，将它们合并为 [1, 5]。
```

提示：

- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `1 <= start(i) <= end(i) <= 10^4`

JavaScript 写法1：

```js
var merge = function (intervals) {
    // 如果intervals数组为空，则返回空数组
    if (intervals.length === 0) return [];
    // 对intervals数组进行排序，以第一个元素的第一个元素为基准
    intervals.sort((a, b) => a[0] - b[0]);
    // 初始化res数组，并将intervals数组的第一个元素放入res数组中
    let res = [intervals[0]];
    // 遍历intervals数组，从第二个元素开始
    for (let i = 1; i < intervals.length; i++) {
        // 获取res数组中最后一个元素
        let prev = res[res.length - 1];
        // 获取intervals数组中当前元素
        let curr = intervals[i];
        // 如果当前元素的第一个元素大于res数组中最后一个元素的第二个元素，则将当前元素的第二个元素和res数组中最后一个元素的第二个元素比较，取最大值
        if (prev[1] >= curr[0]) {
            prev[1] = Math.max(curr[1], prev[1]);
            // 否则，将当前元素放入res数组中
        } else {
            res.push(curr);
        }
    }
    // 返回res数组
    return res;
};
```
