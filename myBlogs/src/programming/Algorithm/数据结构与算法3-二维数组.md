---
title: 数据结构与算法-二维数组
icon: page
order: 3
author: Kevin
date: 2023-12-18
category:
  - 数据结构与算法学习
tags:
  - 数据结构与算法
sticky: true
star: false
footer: 数据结构与算法-二维数组
copyright: No Copyright
---

前面的章节中，我们已经了解了 `一维数组`。然而，有时候，我们可能需要用到 `多维数组`，它更适合像表或矩阵这样更复杂的结构。

<!-- more -->

## 前言

在本文中，我们将重点围绕二维数组来解释：
1. 二维数组在内存中是如何存放的？
2. 如何运用二维数组来解决问题？

## 二维数组简介

`二维数组`是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。

![[Pasted image 20231221102232.png]]

所以二维数组本质上仍然是一个一维数组，内部的一维数组仍然从索引`0`开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。

## 示例

类似一维数组，对于一个二维数组`A = [[1, 2, 3, 4], [2, 4, 5, 6], [1, 4, 6 , 8]]`，计算机同样会在内存中申请一段**连续**的空间，并记录第一行数组的索引位置，即`A[0][0]`的内存地址，他的索引于内存地址的关系如下图所示。

![[Pasted image 20231221102947.png]]

注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值不可能为`1`。实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。

### 旋转矩阵

给你一幅由`N X M`矩阵表示的图像，其中每个像素的大小为4字节。请你设计一种算法，将图像旋转90度。
不占用额外内存空间能否做到？

示例1：

```
给定 matrix = 
[
	[1, 2, 3],
	[4, 5, 6],
	[7, 8, 9]
],

原地旋转输入矩阵，使其变为：
[
	[7, 4, 1],
	[8, 5, 2],
	[9, 6, 3]
]
```

示例2：

```
给定 matrix = 
[
	[ 5, 1, 9,11],
	[ 2, 4, 8,10],
	[13, 3, 6, 7],
	[15,14,12,16]
],

原地旋转输入矩阵，使其变为：
[
	[15,13, 2, 5],
	[14, 3, 4, 1],
	[12, 6, 8, 9],
	[16, 7,10,11]
]
```

JavaScript 写法 1:

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
	const n = matrix.length;
    // 转置矩阵
    for (let i = 0; i < n; i++) {
        // 遍历矩阵的行
        for (let j = i; j < n; j++) {
            // 交换矩阵中第i行和第j行的元素
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
    // 交换行和列
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n / 2; j++) {
            // 交换矩阵中第i行第j列和第i行第n-1-j列的值
            [matrix[i][j], matrix[i][n - 1 - j]] = [matrix[i][n - 1 - j], matrix[i][j]];
        }
    }
    return matrix;
};
```

#### 解题思路：

1. 矩阵转置：将矩阵的行和列进行互换。
2. 矩阵镜像：将矩阵的行和列的元素进行互换。

第一步：

|-|0|1|2|3|
|---|---|---|---|---|
|0|5|1|9|11|
|1|2|4|8|10|
|2|13|3|6|7|
|3|15|14|12|16|

第二步：

|-|0|1|2|3|
|---|---|---|---|---|
|0|5|2|13|15|
|1|1|4|3|14|
|2|9|8|6|12|
|3|11|10|7|16|

第三步：

|-|0|1|2|3|
|---|---|---|---|---|
|0|15|13|2|5|
|1|14|3|4|1|
|2|12|6|8|9|
|3|16|7|10|11|

### 零矩阵

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

示例1：

```
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

示例2：

```
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

JavaScript 写法1：

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
	// 获取矩阵行数
    const m = matrix.length;
    // 获取矩阵列数
    const n = matrix[0].length;
    // 创建行集合
    const rows = new Set();
    // 创建列集合
    const cols = new Set();
    // 遍历矩阵
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 如果矩阵元素为0，则将行和列添加到集合中
            if (matrix[i][j] === 0) {
                rows.add(i);
                cols.add(j);
            }
        }
    }
    // 遍历行集合，将矩阵中对应行元素置为0
    for (let i of rows) {
        for (let j = 0; j < n; j++) {
            matrix[i][j] = 0;
        }
    }
    // 遍历列集合，将矩阵中对应列元素置为0
    for (let j of cols) {
        for (let i = 0; i < m; i++) {
            matrix[i][j] = 0;
        }
    }
    // 返回更新后的矩阵
    return matrix;
};
```

JavaScript 写法2：

```js
/** 
* @param {number[][]} matrix 
* @return {void} Do not return anything, modify matrix in-place instead. 
* */ 
var setZeroes = function (matrix) { 
	let row=[],column=[] 
	// 找到0所在的行或者列 
	for (let i = 0; i < matrix.length; i++) { 
		for (let j = 0; j < matrix[0].length; j++) { 
			if (matrix[i][j] === 0) { 
				row[i] = true; 
				column[j] = true 
			} 
		} 
	} 
	// 置为0 
	for (let i = 0; i < matrix.length; i++) { 
		for (let j = 0; j < matrix[0].length; j++) { 
			if (row[i] || column[j]) { 
				matrix[i][j] = 0;
			 } 
		} 
	} 
	return matrix；
};
```

### 对角线遍历

给你一个大小为 `m x n` 的矩阵 `mat` ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

示例1：

```
输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,4,7,5,3,6,8,9]。
```

示例2：

```
输入：mat = [[1,2],[3,4]]
输出：[1,2,3,4]。
```

提示：

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 104`
- `1 <= m * n <= 104`
- `-105 <= mat[i][j] <= 105`

JavaScript 写法1：

```js
/**
 * @param {number[][]} mat
 * @return {number[]}
 */
var findDiagonalOrder = function(mat) {

};
```
