import{_ as a,W as c,X as i,Y as e,Z as t,$ as o,a1 as r,G as l}from"./framework-d9a58575.js";const n={},u=e("h1",{id:"vue-常见面试题总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue-常见面试题总结","aria-hidden":"true"},"#"),t(" Vue 常见面试题总结")],-1),h={href:"https://juejin.cn/post/7191325434486161467",target:"_blank",rel:"noopener noreferrer"},s=r('<h2 id="什么是mvvm模型" tabindex="-1"><a class="header-anchor" href="#什么是mvvm模型" aria-hidden="true">#</a> 什么是MVVM模型？</h2><ul><li><code>MVVM</code>，是<code>Model-View-ViewModel</code>的简写，其本质是<code>MVC</code>模型的升级版。</li><li>其中 <code>Model</code> 代表数据模型，<code>View</code> 代表看到的页面，<code>ViewModel</code> 是<code>View</code>和<code>Model</code>之间的桥梁，数据会绑定到<code>ViewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>ViewModel</code>层更新数据。</li><li>以前是通过操作DOM来更新视图，现在是数据驱动视图。</li></ul><h2 id="vue的生命周期" tabindex="-1"><a class="header-anchor" href="#vue的生命周期" aria-hidden="true">#</a> Vue的生命周期</h2><ul><li><p>Vue 的生命周期可以分为8个阶段：<code>创建前后</code>、<code>挂载前后</code>、<code>更新前后</code>、销毁前后，以及一些特殊场景的生命周期。</p></li><li><p>Vue 3 中还新增了是3个用于调试和服务端渲染的场景。</p><table><tr><th>Vue 2中的生命周期钩子</th><th>Vue 3选项式API的生命周期选项</th><th>Vue 3组合API的生命周期钩子</th><th>描述</th></tr><tr><td>`beforeCreate`</td><td>`beforeCreate`</td><td>`setup`</td><td>创建前，此时`data`和 `methods`的数据都还没有初始化</td></tr><tr><td>`created`</td><td>`created`</td><td>`setup`</td><td>创建后，`data`中有值，尚未挂载，可以进行一些`Ajax`请求</td></tr><tr><td>`beforeMount`</td><td>`beforeMount`</td><td>`onBeforeMount`</td><td>挂载前，会找到虚拟`DOM`，编译成`Render`</td></tr><tr><td>`mounted`</td><td>`mounted`</td><td>`onMounted`</td><td>挂载后，虚拟`DOM`已创建，可用于获取访问数据和`DOM`元素</td></tr><tr><td>`beforeUpdate`</td><td>`beforeUpdate`</td><td>`onBeforeUpdate`</td><td>更新前，可用于获取更新前的各种状态</td></tr><tr><td>`updated`</td><td>`updated`</td><td>`onUpdated`</td><td>更新后，所有的状态都已是最新的</td></tr><tr><td>`beforeDestroy`</td><td>`beforeUnmount`</td><td>`onBeforeUnmount`</td><td>销毁前，可用于一些定时器或者订阅的取消</td></tr><tr><td>`destroyed`</td><td>`unmounted`</td><td>`onUnmounted`</td><td>销毁后，可用于一些定时器或者订阅的取消</td></tr><tr><td>`activated`</td><td>`activated`</td><td>`onActivated`</td><td>`keep-alive`，缓存的组件激活时</td></tr><tr><td>`deactivated`</td><td>`deactivated`</td><td>`onDeactivated`</td><td>`keep-alive`，缓存的组件停用时</td></tr><tr><td>`errorCaptured`</td><td>`errorCaptured`</td><td>`onErrorCaptured`</td><td>捕获一个来自子孙组件的错误时调用</td></tr><tr><td>——</td><td>`renderTracked`</td><td>`onRenderTracked`</td><td>调试钩子，响应式依赖被收集时调用</td></tr><tr><td>——</td><td>`renderTriggered`</td><td>`onRenderTriggered`</td><td>调试钩子，响应式依赖被触发时调用</td></tr><tr><td>——</td><td>`serverPrefetch`</td><td>`onServerPrefetch`</td><td>组件实例在服务器上被渲染前调用</td></tr></table></li></ul><p><strong>关于Vue 3中的生命周期建议阅读官方文档！！！</strong></p>',5),p={href:"https://cn.vuejs.org/api/composition-api-lifecycle.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://cn.vuejs.org/api/options-lifecycle.html",target:"_blank",rel:"noopener noreferrer"},_=r('<h4 id="父子组件的生命周期" tabindex="-1"><a class="header-anchor" href="#父子组件的生命周期" aria-hidden="true">#</a> <strong>父子组件的生命周期</strong>：</h4><ul><li>加载渲染阶段：父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li><li>更新阶段：父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li>销毁阶段：父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul><h2 id="vue-nexttick" tabindex="-1"><a class="header-anchor" href="#vue-nexttick" aria-hidden="true">#</a> Vue.$nextTick</h2><p><strong>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</strong></p><ul><li><code>nextTick</code> 是<code>Vue</code>提供的一个全局API，由于<code>Vue</code>的异步更新策略，导致我们对数据修改后不会直接体现在<code>DOM</code>上，此时如果想要立即获取更新后的<code>DOM</code>状态，就需要借助该方法。</li><li><code>Vue</code>在更新<code>DOM</code>时是异步执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，并缓冲在同一时间循环中发生的所有数据变更。</li><li>如果同一个<code>watcher</code>被多次触发，只会被推入队列一次。这个在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。</li><li><code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的<code>DOM</code>操作完成后才调用。</li></ul><p>使用场景： 1. 如果想要在修改数据后立刻得到更新后的<code>DOM</code>结构，可以使用<code>Vue.$nextTick</code>。 2. 在<code>created</code>生命周期中进行DOM操作。</p><h2 id="vue-实例挂载过程中发生了什么" tabindex="-1"><a class="header-anchor" href="#vue-实例挂载过程中发生了什么" aria-hidden="true">#</a> Vue 实例挂载过程中发生了什么？</h2><ul><li>挂载过程指的是<code>app.mount()</code>过程，这是一个初始化过程，整体上做了两件事情：<code>初始化</code>和<code>建立更新机制</code>。</li><li>初始化会创建组件实例、初始化组件状态、创建各种响应式数据。</li></ul><h2 id="物联网面临的问题" tabindex="-1"><a class="header-anchor" href="#物联网面临的问题" aria-hidden="true">#</a> 物联网面临的问题</h2><ul><li><p>第一，成本高。</p><ul><li>我国中高端传感器主要依赖进口，同时当前市场上的物联网传感器种类众多，品种繁多就导致难以形成规模效应，</li><li>依赖进口进一步导致边际成本较高，从而导致整个物联网建设成本居高不下，只有降低成本才能更大范围地推动物联网发展。</li></ul></li><li><p>第二，技术不成熟。</p><ul><li>传感器收集数据后，仍需要进行大数据分析才能获得数据价值，</li><li>目前我国大数据挖掘技术、人工智能技术已逐渐发展起来，</li><li>但是这些技术并不是通用的，仍需要与行业相结合，这也扩大了人才需求，</li><li>因此需要加强各垂直行业里的人才、物联网应用人才建设。</li></ul></li><li><p>第三，安全防护。</p><ul><li>物联网本身就与安全有关，其特点是永远在线，且传感器结构较为简单，</li><li>因此做物联网安全防护，既要做到安全，也要做得简单，成本低，三者很难齐头并进式发展。</li></ul></li><li><p>第四，缺少相关法规。</p><ul><li>无处不在的感知，涉及个人隐私的问题，</li><li>在物联网给人们日常生活教育工作发展带来便利的同时，</li><li>国家企业需要我们利用法律法规进行管理规范，涉及用户隐私的数据，谁能用、怎么用等问题。</li></ul></li></ul>',10);function V(M,v){const d=l("ExternalLinkIcon");return c(),i("div",null,[u,e("p",null,[e("a",h,[t("参考自掘金《2023前端面试系列-- Vue 篇》"),o(d)])]),s,e("p",null,[e("a",p,[t("组合式 API：生命周期钩子--官方文档"),o(d)])]),e("p",null,[e("a",f,[t("选项式 API：生命周期选项--官方文档"),o(d)])]),_])}const g=a(n,[["render",V],["__file","2023年vue面试资料.html.vue"]]);export{g as default};
