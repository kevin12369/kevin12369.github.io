---
title: 数据结构与算法-栈与队列
icon: page
order: 5
author: Kevin
date: 2025-12-26
category:
  - 数据结构与算法学习
tag:
  - 数据结构与算法
sticky: true
star: false
footer: 数据结构与算法-栈与队列
copyright: No Copyright
---

> 栈和队列是受限的线性数据结构，在计算机科学中有着广泛的应用

<!-- more -->

## 前言

栈和队列是最重要的受限线性数据结构，它们限制了元素的访问方式，从而在特定场景下提供了更高效的解决方案。

**核心应用**：
- **栈**：函数调用、括号匹配、表达式求值、浏览器历史
- **队列**：任务调度、消息队列、BFS遍历、缓冲区

在本文中，我们将深入探讨：
1. 栈和队列的核心概念
2. 基本操作和实现方式
3. 2025年高频面试题
4. 双端队列、优先队列等高级结构

## 栈（Stack）

### 核心概念

**定义**：后进先出（LIFO - Last In First Out）的线性数据结构

**特点**：
- 只能在栈顶进行插入和删除
- 插入操作称为push（入栈）
- 删除操作称为pop（出栈）
- 查看栈顶元素称为peek/top

**图示**：
```
栈顶 -> [4]  <- push(4)
        [3]
        [2]
        [1]
栈底 -> [ ]  <- pop()返回4
```

### 基本操作

```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """入栈"""
        self.items.append(item)
    
    def pop(self):
        """出栈"""
        if not self.is_empty():
            return self.items.pop()
        return None
    
    def peek(self):
        """查看栈顶元素"""
        if not self.is_empty():
            return self.items[-1]
        return None
    
    def is_empty(self):
        """判断是否为空"""
        return len(self.items) == 0
    
    def size(self):
        """获取栈大小"""
        return len(self.items)
```

### 复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| push | O(1) | 数组末尾插入 |
| pop | O(1) | 数组末尾删除 |
| peek | O(1) | 访问最后一个元素 |
| is_empty | O(1) | 检查长度 |
| size | O(1) | 返回长度 |

## 队列（Queue）

### 核心概念

**定义**：先进先出（FIFO - First In First Out）的线性数据结构

**特点**：
- 在队尾插入元素（enqueue）
- 在队头删除元素（dequeue）
- 先进入的元素先被处理

**图示**：
```
入队 -> [1][2][3][4] -> 出队
队尾              队头
```

### 基本操作

```python
class Queue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        """入队"""
        self.items.append(item)
    
    def dequeue(self):
        """出队"""
        if not self.is_empty():
            return self.items.pop(0)
        return None
    
    def peek(self):
        """查看队头元素"""
        if not self.is_empty():
            return self.items[0]
        return None
    
    def is_empty(self):
        """判断是否为空"""
        return len(self.items) == 0
    
    def size(self):
        """获取队列大小"""
        return len(self.items)
```

### 复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| enqueue | O(1) | 数组末尾插入 |
| dequeue | O(n) | 数组头部删除 |
| peek | O(1) | 访问第一个元素 |
| is_empty | O(1) | 检查长度 |
| size | O(1) | 返回长度 |

**注意**：使用列表实现队列时，dequeue操作是O(n)，因为需要移动所有元素。实际应用中通常使用双端队列或链表实现。

## 高频面试题

### 题目1：有效的括号

**题目描述**：
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

**示例**：
```
输入：s = "()[]{}"
输出：true

输入：s = "([)]"
输出：false
```

#### 解题思路

**方法：使用栈**

1. 遍历字符串
2. 遇到左括号，压入栈
3. 遇到右括号，检查栈顶是否匹配
4. 最后栈为空则有效

#### 代码实现

**Python**：
```python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:
            if not stack or stack[-1] != mapping[char]:
                return False
            stack.pop()
        else:
            stack.append(char)
    
    return len(stack) == 0
```

**JavaScript**：
```javascript
function isValid(s) {
    const stack = [];
    const mapping = {')': '(', '}': '{', ']': '['};
    
    for (const char of s) {
        if (char in mapping) {
            if (!stack.length || stack[stack.length - 1] !== mapping[char]) {
                return false;
            }
            stack.pop();
        } else {
            stack.push(char);
        }
    }
    
    return stack.length === 0;
}
```

#### 复杂度分析
- **时间复杂度**：O(n) - 遍历一次字符串
- **空间复杂度**：O(n) - 最坏情况栈大小为n

### 题目2：用栈实现队列

**题目描述**：
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）。

#### 解题思路

**方法：双栈法**

1. 使用两个栈：inStack和outStack
2. push操作：压入inStack
3. pop操作：从outStack弹出，若为空则将inStack全部倒入outStack

#### 代码实现

**Python**：
```python
class MyQueue:
    def __init__(self):
        self.in_stack = []
        self.out_stack = []
    
    def push(self, x):
        self.in_stack.append(x)
    
    def pop(self):
        self._transfer()
        return self.out_stack.pop()
    
    def peek(self):
        self._transfer()
        return self.out_stack[-1]
    
    def empty(self):
        return not self.in_stack and not self.out_stack
    
    def _transfer(self):
        if not self.out_stack:
            while self.in_stack:
                self.out_stack.append(self.in_stack.pop())
```

#### 复杂度分析
- **push**：O(1) - 平均时间复杂度
- **pop**：O(1) - 平均时间复杂度
- **peek**：O(1)
- **empty**：O(1)

### 题目3：逆波兰表达式求值

**题目描述**：
根据逆波兰表示法，求表达式的值。有效的运算符包括 +、-、*、/ 。

**示例**：
```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：((2 + 1) * 3) = 9
```

#### 解题思路

**方法：使用栈**

1. 遍历表达式
2. 遇到数字，压入栈
3. 遇到运算符，弹出两个数字计算，结果压入栈
4. 最后栈中剩下的就是结果

#### 代码实现

**Python**：
```python
def evalRPN(tokens):
    stack = []
    
    for token in tokens:
        if token in '+-*/':
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            elif token == '/':
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    
    return stack[0]
```

#### 复杂度分析
- **时间复杂度**：O(n) - 遍历一次表达式
- **空间复杂度**：O(n) - 栈大小

## 高级数据结构

### 双端队列（Deque）

**定义**：两端都可以进行插入和删除的队列

**操作**：
- appendleft：从左端插入
- popleft：从左端删除
- append：从右端插入
- pop：从右端删除

**Python实现**：
```python
from collections import deque

d = deque()
d.append(1)  # [1]
d.appendleft(0)  # [0, 1]
d.pop()  # [0]
d.popleft()  # []
```

### 优先队列（Priority Queue）

**定义**：每个元素都有优先级，优先级高的先出队

**实现**：通常使用堆（Heap）

**Python实现**：
```python
import heapq

# 最小堆
heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 2)
print(heapq.heappop(heap))  # 1

# 最大堆（通过取负数实现）
heap = []
heapq.heappush(heap, -3)
heapq.heappush(heap, -1)
heapq.heappush(heap, -2)
print(-heapq.heappop(heap))  # 3
```

### 循环队列

**定义**：首尾相连的队列

**优势**：
- 避免数据搬移
- 空间利用率高

**实现**：
```python
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = 0
        self.size = 0
    
    def enqueue(self, item):
        if self.is_full():
            return False
        self.queue[self.rear] = item
        self.rear = (self.rear + 1) % self.capacity
        self.size += 1
        return True
    
    def dequeue(self):
        if self.is_empty():
            return None
        item = self.queue[self.front]
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return item
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity
```

## 实际应用

### 1. 浏览器前进后退

```python
class BrowserHistory:
    def __init__(self, homepage):
        self.history = [homepage]
        self.current = 0
    
    def visit(self, url):
        # 删除当前页面之后的所有历史
        self.history = self.history[:self.current + 1]
        self.history.append(url)
        self.current += 1
    
    def back(self, steps):
        self.current = max(0, self.current - steps)
        return self.history[self.current]
    
    def forward(self, steps):
        self.current = min(len(self.history) - 1, self.current + steps)
        return self.history[self.current]
```

### 2. 任务调度器

```python
from collections import deque

class TaskScheduler:
    def __init__(self):
        self.queue = deque()
    
    def add_task(self, task):
        self.queue.append(task)
    
    def execute_next(self):
        if self.queue:
            return self.queue.popleft()
        return None
    
    def peek_next(self):
        if self.queue:
            return self.queue[0]
        return None
```

### 3. 函数调用栈

```python
class CallStack:
    def __init__(self):
        self.stack = []
    
    def call(self, function):
        self.stack.append(function)
        print(f"调用函数: {function}")
    
    def return_(self):
        if self.stack:
            function = self.stack.pop()
            print(f"从函数返回: {function}")
            return function
        return None
    
    def current_function(self):
        if self.stack:
            return self.stack[-1]
        return None
```

## 常见陷阱

### 1. 栈溢出

**常见错误**：
```python
# 错误：无限递归导致栈溢出
def factorial(n):
    return n * factorial(n - 1)  # 缺少终止条件
```

**正确做法**：
```python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

### 2. 队列空操作

**常见错误**：
```python
# 错误：未检查队列是否为空
queue = Queue()
item = queue.dequeue()  # 可能返回None
process(item)  # 处理None值
```

**正确做法**：
```python
queue = Queue()
if not queue.is_empty():
    item = queue.dequeue()
    process(item)
```

## 2025年面试趋势

### 1. 综合考察

**趋势**：
- 栈 + 递归
- 队列 + BFS
- 双端队列 + 滑动窗口

### 2. 实际场景

**趋势**：
- 任务调度系统
- 消息队列设计
- 缓存系统设计

### 3. 性能优化

**趋势**：
- 时间复杂度分析
- 空间复杂度优化
- 并发安全考虑

## 总结

栈和队列是受限的线性数据结构，掌握它们的关键在于：

1. **理解LIFO和FIFO**：清楚各自的访问顺序
2. **掌握基本操作**：入栈/出栈、入队/出队
3. **熟练应用场景**：括号匹配、任务调度等
4. **了解高级结构**：双端队列、优先队列等
5. **注意边界条件**：空栈/空队列、栈溢出等

**学习建议**：
- 多画图理解操作过程
- 练习经典题目
- 结合实际应用场景
- 注意时间复杂度分析

**下一步**：让我们继续学习树，掌握非线性数据结构的核心。

---

**参考资料**：
- LeetCode：https://leetcode.cn/
- 《剑指Offer》
- 《算法图解》