---
title: 数据结构与算法-数组
icon: page
order: 2
author: Kevin
date: 2023-12-18
category:
  - 数据结构与算法学习
tags:
  - 数据结构与算法
sticky: true
star: false
footer: 数据结构与算法-数组
copyright: No Copyright
---

`数组`是数据结构中的基本模块之一。因为`字符串`是由字符数组形成的，所以二者是相似的。大多数面试问题都属于这个范畴。

<!-- more -->

## 前言

在本文中，我们将介绍`数组`和`字符串`。完成后，你将：
1. 理解数组的`基本概念`及其`操作方式`；
2. 理解`二维数组`的基本概念，熟悉二维数组的使用；
3. 了解`字符串`的概念以及字符串所具有的不同特性；
4. 理解字符串匹配中的`KMP 算法`；
5. 能够运用`双指针`解决实际问题。

## 集合、列表和数组

> 本文中介绍的概念为适用于所有编程语言的抽象理论，具体实现会有编程语言的不同而稍有差别。

具体介绍数组之前，我们先来了解一下集合、列表和数组的概念之间的差别。

### 集合

[集合](https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117?fr=aladdin)一般被定义为：由一个或多个确定的元素所构成的整体。

通俗来讲，集合就是将一组事物组合在一起。
集合有什么特性呢？
首先，集合里的元素类型不一定相同。你可以将商品看作一个集合，也可以将整个商店看作是一个集合，这个商店中有人或者其他物品也没有关系。
其次，集合里的元素没有顺序。我们不会这样讲：我想要集合中的第三个元素，因为集合是没有顺序的。
事实上，这样的集合并不直接存在于编程语言中。然而，实际编程语言中的很多数据结构，就是在集合的基础上添加了一些规则形成的。

### 列表

[列表](https://baike.baidu.com/item/%E5%88%97%E8%A1%A8)（又称线性列表）的定义为：是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。

列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。你可以把它看作一张购物清单：

![[Pasted image 20231218173943.png]]

在这张清单中：

购物清单中的条目代表的类型可能不同，但是按照一定顺序进行了排列；
购物清单的长度是可变的，你可以向购物清单中增加、删除条目。
在编程语言中，列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表。除此之外，向列表中添加、删除元素的具体实现方式会根据编程语言的不同而有所区分。

### 数组

数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。
正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如C++和Java中，数组中的元素类型必须保持一致，而Python中则可以不同。Python中的数组叫做List，具有更多的高级功能。
那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：索引。
首先，数组会用一些名为`索引`的数字来表示没想数据在数组中的位置，且在大多数编程语言中，索引是从`0`算起的。我们可以根据数组中索引，快速访问数组中的元素。

![[Pasted image 20231218174544.png]]
而列表中没有索引，这是数组与列表最大的不同点。
其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。要理解这一点，我们需要了解数组在内存中的存储方式，我们将在下一节中详细介绍。

![[Pasted image 20231218174844.png]]
相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，他的元素在内存中则不一定是连续的。有关链表的介绍，可以在探索卡片「链表」中进行进一步学习。

## 数组的操作

> 本节重点讲解一下数组的4中操作。

要重点学的知识点基本就是大纲中提到的哪些，图论这一块了解即可，优先级不高，面试考的也不多。链表、树是面试的重点。

推荐直接从LeetCode的学习板块LeetBook开始刷起，边学边写代码，学的更扎实。

#### 读取元素

读取数组中的元素，是通过访问索引的方式在读取的，索引一般从`0`开始。
在计算机中，内存可以看成时一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。

![[Pasted image 20231219094215.png]]
而对于数组，计算机会在内存中为其申请一段连续的空间并且会记下索引为`0`处的内存地址。以数组`["C","O","D","E","R"]`为例，它的各元素对应的索引及内存地址如下图所示。
![[Pasted image 20231219095700.png]]
假如我们想要访问索引为`2`处的元素`"D"`时，计算机会进行以下计算：
- 找到该数组的索引`0`的内存地址：`2008`;
- 将内存地址加上索引值，作为目标元素的地址。即`2008 + 2 = 2010`，对应元素的`"D"`，这时便找到了目标元素。
我们知道，计算内存地址这个过程很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此他的时间复杂度是常数级别，为O(1)。

#### 查找元素

假如我们堆数组包含哪些元素并不了解，只是想知道其中是否含有元素`"E"`，数组会如何查找元素`"E"`呢？与读取元素类似，由于我们只保存了索引为`0`处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾。
![[Pasted image 20231219141511.png]]
我们发现，最坏情况下，搜索的元素为`"R"`，或者数组中不包括目标元素时，我们需要查找`n`次，`n`为数组的长度，因此查找元素的时间复杂度为O(N)，N为数组的长度。

#### 插入元素

假如我们想在原有的数组中再插入一个元素`"S"`呢？
如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。
![[Pasted image 20231219142113.png]]
然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置腾出空间，然后进行插入操作。比如，我们想要再索引`2`处插入`"S"`。
![[Pasted image 20231219142346.png]]
我们发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一个数据结构，即链表可以有效解决这个问题，我们将在另外的卡片中进行学习。

#### 删除元素

删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下空缺的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行填补操作。
已删除索引`1`中的元素`"0"`为例，具体过程如图所示。
![[Pasted image 20231219142923.png]]
当数组的长度为`n`时，最坏情况下，我们删除第一个元素，共需要的步骤数为`1 + (n - 1) = n`步，其中，`1`为删除操作，`n - 1`为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为O(N)，N为数组的长度。

### 寻找数组的中心索引

给你一个整数数组`nums`，请计算数组的中心下标。
数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有水元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和为`0`，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回最靠近左边的那一个。如果数组不窜在中心下标，返回`-1`。

示例1：

```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = num[0] + num[1] + num[2] = 1 + 7 + 3 = 11 ,
右侧数之和 sum = num[4] + num[5] = 5 + 6 = 11，二者相等。
```

示例2：

```
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

示例3：

```
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```

提示：

- `1 <= nums.length <= 10^4`
- `-1000 <= nums[i] <= 1000`
- `Array.prototype.reduce()` 是 JavaScript 中的一个内置方法，它用于对数组中的元素进行累积操作。这个方法接受两个参数：一个回调函数和一个初始值。
	- 回调函数接受四个参数：
		1. `accumulator`：累积器，它累积回调的返回值。它是上一次回调返回的累积值，或者是提供的初始值（在没有初始值的情况下）。    
		2. `currentValue`：当前值，正在处理的数组元素。 
		3. `currentIndex`（可选）：当前索引，正在处理的数组元素的索引。
		4. `array`（可选）：调用 `reduce` 的数组。
		5. `初始值`（可选）：作为第一次调用 `callback` 函数时的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。在没有初始值的空数组上调用 reduce 将报错。

JavaScript 写法 1:

```js
/**
* @param {number[]} nums
* @return {number}
*/
// 计算数组nums的和
var pivotIndex = function (nums) {
	const rightSum = nums.reduce((a, c)=> a + c, 0);
	// 初始化左边和
	let leftSum = 0;
	// 遍历数组nums
	for (let i = 0; i < nums.length; i++) {
		// 如果左边和等于总和减去左边和减去当前元素
		if (leftSum * 2 + nums[i] === rightSum) {
			// 返回当前元素下标
			return i;
		}
		// 左边和加上当前元素
		leftSum += nums[i];
	}
	// 如果没有找到，返回-1
	return -1;
}
```

JavaScript 写法 2:

```js
/**
* @param {number[]} nums
* @return {number}
*/
// 计算数组nums的和
var pivotIndex = function (nums) {
	const rightSum = nums.reduce((a, c)=> a + c, 0);
	// 初始化左边和
	let leftSum = 0;
	// 遍历数组nums
	for (let i = 0; i < nums.length; i++) {
		// 如果左边和等于总和减去左边和减去当前元素
		if (leftSum === rightSum - leftSum - nums[i]) {
			// 返回当前元素下标
			return i;
		}
		// 左边和加上当前元素
		leftSum += nums[i];
	}
	// 如果没有找到，返回-1
	return -1;
}
```

### LeetCode 题解：

#### 解题思路

题目仅说明是整数数组，无其他已知条件，因此考虑直接遍历数组。
- 设索引 i 对应变量 「左侧元素相加和`sum_left`」和「右侧元素相加和`sum_right`」。
- 遍历数组`nums`，每轮更新`sum_left`和`sum_right`。
- 遍历中，遇到满足`sum_left == sum_right`时，说明当前索引为中心下标，返回即可。
- 若遍历完成，仍未找到「中心下标」，则返回 -1。

初始化时，相当于索引 i = -1，此时`sum_left = 0`，`sum_right = 所有元素的和`。

> 首页为动态图，其余页为静态图，方便一步步看。

#### 代码

需要考虑大数越界问题。题目给定整数数组`nums`，并给定取值范围。
- `1 <= nums.length <= 10^4`
- `-1000 <= nums[i] <= 1000`

易得「元素相加和」的取值范围为 [-10^7, 10^7]，在`int`类型的取值范围内，因此`sum_left`和`sum_right`使用int类型即可。

python 写法：

```python
class Solution:
	def pivotIndex(self, nums:List[int]) -> int:
		sum_left, sum_right = 0, sum(nums)
		for i in range(len(nums)):
			sum_right -= nums[i]
			# 若左侧元素和等于右侧元素和，返回中心下标 i
			if sum_left == sum_right:
				return i
			sum_left += nums[i]
		return -1
```

Java 写法：

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sumLeft = 0, sumRight = Arrays.stream(nums).sum();
        for (int i = 0; i < nums.length; i++) {
            sumRight -= nums[i];
            // 若左侧元素和等于右侧元素和，返回中心下标 i
            if (sumLeft == sumRight)
                return i;
            sumLeft += nums[i];
        }
        return -1;
    }
}
```

C++ 写法：

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sumLeft = 0, sumRight = accumulate(nums.begin(), nums.end(), 0);
        for (int i = 0; i < nums.size(); i++) {
            sumRight -= nums[i];
            // 若左侧元素和等于右侧元素和，返回中心下标 i
            if (sumLeft == sumRight)
                return i;
            sumLeft += nums[i];
        }
        return -1;
    }
};
```

#### 复杂度分析

- 时间复杂度O(N)：其中N为数组`nums`长度。求和操作使用O(N)线性时间，遍历`nums`最差使用O(N)线性时间。
- 空间复杂度O(1)：变量`sum_left`，`sum_right`使用常数大小空间。

### 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，**返回它将会被按顺序插入的位置**。
请必须使用时间复杂度为`O(log n)`的算法。

示例1：

```
输入： nums = [1, 3, 5, 6], target = 5
输出： 2
```

示例2：

```
输入： nums = [1, 3, 5, 6], target = 2
输出： 1
```

示例3：

```
输入： nums = [1, 3, 5, 6], target = 7
输出： 4
```

JavaScript 写法1：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
// 二分查找，效率高
var searchInsert = function (nums, target) {
    // 定义左右指针
    let left = 0;
    let right = nums.length - 1;
    // 当左指针小于等于右指针时，循环查找
    while (left <= right) {
        // 计算中间值
        let mid = Math.floor((left + right) / 2);
        // 如果中间值等于目标值，返回中间值
        if (nums[mid] === target) {
            return mid;
            // 如果中间值小于目标值，左指针右移
        } else if (nums[mid] < target) {
            left = mid + 1;
            // 如果中间值大于目标值，右指针左移
        } else {
            right = mid - 1;
        }
    }
    // 返回左指针
    return left;
};
```

JavaScript 写法2：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
// 暴力查找，元素少的时候效率高，元素多的时候效率低
var searchInsert = function (nums, target) {
    // 遍历数组，查找插入位置
    for (let i = 0; i < nums.length; i++) {
        // 如果target小于等于当前元素，则返回当前位置
        if (target <= nums[i]) {
            return i;
        }
    }
    // 如果target大于数组中所有元素，则返回数组长度
    return nums.length;
};
```

### 合并区间

以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [start(i), end(i)]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

示例1：

```
输入： intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
输出： [[1, 6], [8, 10], [15, 18]]
解决： 区间 [1, 3] 和 [2, 6] 重叠，将它们合并为 [1, 6]。
```

示例2：

```
输入： intervals = [[1, 4], [4, 5]]
输出： [[1, 5]]
解决： 区间 [1, 4] 和 [4, 5] 重叠，将它们合并为 [1, 5]。
```

提示：

- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `1 <= start(i) <= end(i) <= 10^4`

JavaScript 写法1：

```js
var merge = function (intervals) {
    // 如果intervals数组为空，则返回空数组
    if (intervals.length === 0) return [];
    // 对intervals数组进行排序，以第一个元素的第一个元素为基准
    intervals.sort((a, b) => a[0] - b[0]);
    // 初始化res数组，并将intervals数组的第一个元素放入res数组中
    let res = [intervals[0]];
    // 遍历intervals数组，从第二个元素开始
    for (let i = 1; i < intervals.length; i++) {
        // 获取res数组中最后一个元素
        let prev = res[res.length - 1];
        // 获取intervals数组中当前元素
        let curr = intervals[i];
        // 如果当前元素的第一个元素大于res数组中最后一个元素的第二个元素，则将当前元素的第二个元素和res数组中最后一个元素的第二个元素比较，取最大值
        if (prev[1] >= curr[0]) {
            prev[1] = Math.max(curr[1], prev[1]);
            // 否则，将当前元素放入res数组中
        } else {
            res.push(curr);
        }
    }
    // 返回res数组
    return res;
};
```
