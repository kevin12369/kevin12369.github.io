---
icon: edit
date: 2025-01-02
category:
  - 前端面试
tag:
  - 前端工程化
sticky: false
lastUpdated: true
footer: 前端工程化总结
---

# 前端工程化总结（2025版）

## 2025年前端工程化趋势

- **Vite 成为主流**：取代 Webpack 成为默认构建工具
- **Monorepo 普及**：pnpm workspace、Turborepo
- **CI/CD 自动化**：GitHub Actions、GitLab CI
- **微前端架构**：qiankun、Module Federation
- **低代码平台**：提升开发效率

## 什么是前端工程化？

前端工程化是指使用软件工程的技术和方法，来规范前端开发流程，提高开发效率、代码质量和可维护性。

**核心要素**：
1. **模块化**：代码组织
2. **组件化**：UI 组件复用
3. **规范化**：代码规范、Git 规范
4. **自动化**：构建、测试、部署
5. **工具化**：开发工具、调试工具

## 模块化

### 1. 模块化方案

**CommonJS**（Node.js）：
```javascript
// 导出
module.exports = {
  name: 'module'
};

// 或
exports.name = 'module';

// 导入
const module = require('./module');
```

**ES Modules**（现代浏览器、Node.js）：
```javascript
// 导出
export const name = 'module';
export default function() {}

// 导入
import module, { name } from './module';
```

**AMD**（RequireJS）：
```javascript
// 定义模块
define(['dependency'], function(dependency) {
  return {
    name: 'module'
  };
});

// 使用模块
require(['module'], function(module) {
  console.log(module.name);
});
```

**UMD**（通用模块定义）：
```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['dependency'], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('dependency'));
  } else {
    root.Module = factory(root.Dependency);
  }
}(this, function (dependency) {
  return {
    name: 'module'
  };
}));
```

### 2. 模块化最佳实践

- 优先使用 ES Modules
- 使用绝对路径导入
- 避免循环依赖
- 合理拆分模块

## 构建工具

### 3. Webpack

**核心概念**：
- **Entry**：入口
- **Output**：输出
- **Loader**：转换器
- **Plugin**：插件
- **Mode**：模式

**配置示例**：
```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
    clean: true
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader'
        }
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(png|jpg|gif)$/,
        type: 'asset/resource'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ],
  optimization: {
    splitChunks: {
      chunks: 'all'
    }
  },
  devServer: {
    static: './dist',
    hot: true
  }
};
```

### 4. Vite

**优势**：
- 极快的冷启动
- 即时热更新（HMR）
- 原生 ES Modules 支持
- 开箱即用的 TypeScript 支持

**配置示例**：
```javascript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  },
  server: {
    port: 3000,
    proxy: {
      '/api': 'http://localhost:8080'
    }
  }
});
```

### 5. Webpack vs Vite

| 特性 | Webpack | Vite |
|------|---------|------|
| 启动速度 | 慢 | 快 |
| HMR 速度 | 慢 | 快 |
| 配置复杂度 | 高 | 低 |
| 生态成熟度 | 高 | 中 |
| 适用场景 | 大型项目 | 中小型项目 |

## 包管理工具

### 6. npm vs yarn vs pnpm

**npm**：
```bash
npm install
npm run build
```

**yarn**：
```bash
yarn install
yarn build
```

**pnpm**（推荐）：
```bash
pnpm install
pnpm build
```

**pnpm 优势**：
- 节省磁盘空间
- 更快的安装速度
- 严格的依赖管理
- 支持 Monorepo

### 7. Monorepo

**pnpm workspace**：
```json
// pnpm-workspace.yaml
packages:
  - 'packages/*'

// package.json
{
  "name": "my-monorepo",
  "private": true,
  "scripts": {
    "dev": "pnpm --filter './packages/**' dev",
    "build": "pnpm --filter './packages/**' build"
  }
}
```

**Turborepo**：
```json
// turbo.json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": ["coverage/**"]
    }
  }
}
```

## 代码规范

### 8. ESLint

**配置示例**：
```javascript
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:@typescript-eslint/recommended'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    }
  },
  plugins: [
    'react',
    'react-hooks',
    '@typescript-eslint'
  ],
  rules: {
    'no-console': 'warn',
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': 'error'
  }
};
```

### 9. Prettier

**配置示例**：
```json
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100
}
```

### 10. Stylelint

**配置示例**：
```javascript
module.exports = {
  extends: [
    'stylelint-config-standard',
    'stylelint-config-recommended-scss'
  ],
  rules: {
    'indentation': 2,
    'string-quotes': 'single',
    'no-duplicate-selectors': true
  }
};
```

### 11. Husky + lint-staged

**配置 Husky**：
```bash
npm install husky --save-dev
npx husky install
npx husky add .husky/pre-commit "npx lint-staged"
```

**配置 lint-staged**：
```json
{
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss}": [
      "stylelint --fix",
      "prettier --write"
    ],
    "*.{json,md}": [
      "prettier --write"
    ]
  }
}
```

## CI/CD

### 12. GitHub Actions

**配置示例**：
```yaml
name: CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: pnpm install
      - name: Run tests
        run: pnpm test
      - name: Build
        run: pnpm build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          vercel-args: '--prod'
```

### 13. GitLab CI

**配置示例**：
```yaml
stages:
  - test
  - build
  - deploy

test:
  stage: test
  script:
    - pnpm install
    - pnpm test

build:
  stage: build
  script:
    - pnpm build
  artifacts:
    paths:
      - dist/

deploy:
  stage: deploy
  script:
    - npm run deploy
  only:
    - main
```

## 测试

### 14. 单元测试

**Jest**：
```javascript
// math.test.js
import { add, subtract } from './math';

describe('Math', () => {
  test('add', () => {
    expect(add(1, 2)).toBe(3);
  });

  test('subtract', () => {
    expect(subtract(5, 3)).toBe(2);
  });
});
```

**Vitest**（推荐）：
```javascript
// math.test.js
import { describe, it, expect } from 'vitest';
import { add, subtract } from './math';

describe('Math', () => {
  it('add', () => {
    expect(add(1, 2)).toBe(3);
  });

  it('subtract', () => {
    expect(subtract(5, 3)).toBe(2);
  });
});
```

### 15. 端到端测试

**Cypress**：
```javascript
// cypress/e2e/home.cy.js
describe('Home Page', () => {
  it('should display welcome message', () => {
    cy.visit('/');
    cy.contains('Welcome');
  });

  it('should navigate to about page', () => {
    cy.visit('/');
    cy.get('a[href="/about"]').click();
    cy.url().should('include', '/about');
  });
});
```

**Playwright**（推荐）：
```javascript
// tests/home.spec.ts
import { test, expect } from '@playwright/test';

test('should display welcome message', async ({ page }) => {
  await page.goto('/');
  await expect(page.locator('text=Welcome')).toBeVisible();
});

test('should navigate to about page', async ({ page }) => {
  await page.goto('/');
  await page.click('a[href="/about"]');
  await expect(page).toHaveURL(/.*\/about/);
});
```

## 部署

### 16. 部署平台

**Vercel**：
```bash
npm install -g vercel
vercel
```

**Netlify**：
```bash
npm install -g netlify-cli
netlify deploy --prod
```

**Docker**：
```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

### 17. Docker Compose

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - db

  db:
    image: postgres:14
    environment:
      - POSTGRES_PASSWORD=password
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:
```

## 微前端

### 18. qiankun

**主应用**：
```javascript
// main.js
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'reactApp',
    entry: '//localhost:7100',
    container: '#container',
    activeRule: '/react',
  },
  {
    name: 'vueApp',
    entry: '//localhost:7200',
    container: '#container',
    activeRule: '/vue',
  },
]);

start();
```

**子应用**：
```javascript
// public-path.js
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}

// main.js
import './public-path';
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

let root;

function render(props) {
  const { container } = props;
  root = ReactDOM.createRoot(
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
  root.render(<App />);
}

if (!window.__POWERED_BY_QIANKUN__) {
  render({});
}

export async function bootstrap() {
  console.log('[react16] react app bootstraped');
}

export async function mount(props) {
  console.log('[react16] props from main framework', props);
  render(props);
}

export async function unmount(props) {
  const { container } = props;
  root.unmount(
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}
```

### 19. Module Federation

**配置示例**：
```javascript
// webpack.config.js
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app1',
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/Button',
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

## 性能优化

### 20. 构建优化

**代码分割**：
```javascript
// 动态导入
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// 路由级别代码分割
const Home = () => import('./views/Home.vue');
```

**Tree Shaking**：
```javascript
// 使用 ES6 模块
import { debounce } from 'lodash-es';

// 配置
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
  },
};
```

**压缩**：
```javascript
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
          },
        },
      }),
    ],
  },
};
```

## 2025年新技术

### 21. Bun

**特点**：
- 更快的包管理
- 内置测试框架
- 原生 TypeScript 支持

```bash
bun install
bun run build
bun test
```

### 22. Nx

**特点**：
- 高性能 Monorepo 工具
- 智能缓存
- 并行执行

```bash
npx create-nx-workspace@latest my-workspace
```

### 23. Rspack

**特点**：
- Rust 编写
- 兼容 Webpack API
- 更快的构建速度

```javascript
module.exports = {
  mode: 'development',
  devServer: {
    port: 3000,
  },
};
```

## 最佳实践

### 24. 工程化最佳实践

**项目结构**：
```
my-project/
├── src/
│   ├── assets/
│   ├── components/
│   ├── pages/
│   ├── styles/
│   ├── utils/
│   ├── App.js
│   └── index.js
├── public/
├── tests/
├── docs/
├── .eslintrc.js
├── .prettierrc
├── package.json
├── tsconfig.json
├── vite.config.js
└── README.md
```

**Git 工作流**：
1. `main`：生产环境
2. `develop`：开发环境
3. `feature/*`：功能分支
4. `bugfix/*`：修复分支
5. `hotfix/*`：紧急修复

**Commit 规范**：
```
feat: 添加新功能
fix: 修复bug
docs: 文档更新
style: 代码格式调整
refactor: 重构
test: 测试相关
chore: 构建/工具相关
```

### 25. 工程化清单

**开发阶段**：
- [ ] 使用 Vite 或 Webpack
- [ ] 配置 TypeScript
- [ ] 配置 ESLint、Prettier
- [ ] 配置 Husky、lint-staged
- [ ] 使用 Git Flow 工作流

**测试阶段**：
- [ ] 配置单元测试
- [ ] 配置 E2E 测试
- [ ] 配置测试覆盖率
- [ ] 集成 CI/CD

**部署阶段**：
- [ ] 配置构建优化
- [ ] 配置环境变量
- [ ] 配置自动化部署
- [ ] 配置监控告警

## 常见问题

### 26. 如何选择构建工具？

**选择 Vite**：
- 中小型项目
- 快速原型开发
- 需要快速启动

**选择 Webpack**：
- 大型项目
- 复杂的构建需求
- 需要丰富的插件生态

### 27. 如何优化构建速度？

1. **使用缓存**：Webpack cache、Vite 预构建缓存
2. **并行处理**：thread-loader、happypack
3. **减少依赖**：按需引入、使用轻量级库
4. **使用更快的工具**：pnpm、Bun、Rspack

## 总结

前端工程化是现代前端开发的基础，它通过模块化、规范化、自动化等手段，提高了开发效率和代码质量。选择合适的工具和流程，建立完善的工程化体系，是项目成功的关键。

**工程化原则**：
1. **自动化优先**：减少手动操作
2. **规范化统一**：统一代码风格和流程
3. **可维护性**：代码易于理解和修改
4. **可扩展性**：系统易于扩展和升级

## 参考链接

[Vite 官方文档](https://vitejs.dev/)
[Webpack 官方文档](https://webpack.js.org/)
[GitHub Actions 文档](https://docs.github.com/en/actions)
[qiankun 官方文档](https://qiankun.umijs.org/)