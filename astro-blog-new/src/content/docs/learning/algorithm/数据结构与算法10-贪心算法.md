---
language: 'zh-CN'
title: '数据结构与算法10-贪心算法'
description: '贪心算法通过局部最优选择来寻找全局最优解，简单高效但适用范围有限。本文详解贪心算法的原理和应用。'
publishDate: '2024-01-01'
tags: []
---


> 贪心算法通过局部最优选择来寻找全局最优解，简单高效但适用范围有限

<!-- more -->

## 前言

贪心算法是一种在每一步选择中都采取当前状态下最优（或最有利）的选择，从而希望导致结果是全局最优的算法。

**核心应用**：
- **活动选择**：会议室调度
- **最短路径**：Dijkstra算法
- **最小生成树**：Prim算法、Kruskal算法
- **哈夫曼编码**：数据压缩

在本文中，我们将深入探讨：
1. 贪心算法的核心思想
2. 贪心算法的适用条件
3. 经典贪心问题
4. 2025年高频面试题

## 贪心算法基础

### 核心思想

**定义**：贪心算法在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。

**关键特征**：
1. **贪心选择性质**：每一步都做出当前最优选择
2. **最优子结构**：问题的最优解包含子问题的最优解

### 贪心算法 vs 动态规划

| 特性 | 贪心算法 | 动态规划 |
|------|---------|---------|
| 决策方式 | 每步局部最优 | 考虑所有可能 |
| 时间复杂度 | 通常较低 | 通常较高 |
| 适用范围 | 有限 | 广泛 |
| 最优性 | 不一定保证 | 保证最优 |

**示例：找零问题**

```python
# 贪心算法 - 不一定最优
def coin_change_greedy(amount, coins):
    coins.sort(reverse=True)
    count = 0
    for coin in coins:
        count += amount // coin
        amount %= coin
    return count

# 动态规划 - 一定最优
def coin_change_dp(amount, coins):
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != amount + 1 else -1
```

### 适用条件

贪心算法能获得最优解的两个必要条件：

#### 1. 贪心选择性质

**定义**：一个全局最优解可以通过一系列局部最优的选择来达到。

**示例**：活动选择问题
- 每次选择结束时间最早的活动
- 这样可以为后面的活动留出更多时间

#### 2. 最优子结构

**定义**：问题的最优解包含其子问题的最优解。

**示例**：最短路径问题
- 从A到B的最短路径，包含从A到B路径上某点C的最短路径

## 经典贪心问题

### 1. 活动选择问题

**题目**：给定n个活动，每个活动有开始时间和结束时间，求能参加的最多活动数量。

**贪心策略**：每次选择结束时间最早的活动。

**代码实现**：
```python
def activity_selection(activities):
    # 按结束时间排序
    activities.sort(key=lambda x: x[1])
    
    selected = [activities[0]]
    last_end = activities[0][1]
    
    for activity in activities[1:]:
        start, end = activity
        if start >= last_end:
            selected.append(activity)
            last_end = end
    
    return selected

# 示例
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]
result = activity_selection(activities)
print(result)  # [(1, 4), (5, 7), (8, 11), (12, 16)]
```

### 2. 分发饼干

**题目**：假设你是一位很棒的家长，想要给你的孩子们分发小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**贪心策略**：将最小的饼干分给胃口最小的孩子。

**代码实现**：
```python
def findContentChildren(g, s):
    g.sort()  # 孩子胃口
    s.sort()  # 饼干尺寸
    
    child = cookie = 0
    while child < len(g) and cookie < len(s):
        if s[cookie] >= g[child]:
            child += 1
        cookie += 1
    
    return child

# 示例
g = [1, 2, 3]
s = [1, 1]
result = findContentChildren(g, s)
print(result)  # 1
```

### 3. 无重叠区间

**题目**：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**贪心策略**：按结束时间排序，选择结束时间最早的区间。

**代码实现**：
```python
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    # 按结束时间排序
    intervals.sort(key=lambda x: x[1])
    
    count = 1
    end = intervals[0][1]
    
    for interval in intervals[1:]:
        if interval[0] >= end:
            count += 1
            end = interval[1]
    
    return len(intervals) - count

# 示例
intervals = [[1,2],[2,3],[3,4],[1,3]]
result = eraseOverlapIntervals(intervals)
print(result)  # 1
```

### 4. 跳跃游戏

**题目**：给定一个非负整数数组 nums，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

**贪心策略**：维护能够到达的最远位置。

**代码实现**：
```python
def canJump(nums):
    max_reach = 0
    
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
    
    return True

# 示例
nums = [2,3,1,1,4]
result = canJump(nums)
print(result)  # True
```

### 5. 加油站

**题目**：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

**贪心策略**：从总油量大于总消耗量的加油站出发。

**代码实现**：
```python
def canCompleteCircuit(gas, cost):
    total_gas = 0
    total_cost = 0
    current_gas = 0
    start = 0
    
    for i in range(len(gas)):
        total_gas += gas[i]
        total_cost += cost[i]
        current_gas += gas[i] - cost[i]
        
        if current_gas < 0:
            start = i + 1
            current_gas = 0
    
    return start if total_gas >= total_cost else -1

# 示例
gas = [1,2,3,4,5]
cost = [3,4,5,1,2]
result = canCompleteCircuit(gas, cost)
print(result)  # 3
```

## 高频面试题

### 题目1：买卖股票的最佳时机

**题目描述**：
给定一个数组 prices，它的第 i 个元素 prices[i] 是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一只股票），设计一个算法来计算你所能获取的最大利润。

**示例**：
```
输入：[7,1,5,3,6,4]
输出：5
解释：在第2天（价格=1）的时候买入，在第5天（价格=6）的时候卖出，最大利润 = 6-1 = 5。
```

#### 解题思路

**方法：贪心算法**

记录最小价格，计算每天的最大利润。

#### 代码实现

**Python**：
```python
def maxProfit(prices):
    if not prices:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for price in prices[1:]:
        max_profit = max(max_profit, price - min_price)
        min_price = min(min_price, price)
    
    return max_profit
```

#### 复杂度分析
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)

### 题目2：买卖股票的最佳时机 II

**题目描述**：
给定一个数组 prices，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**示例**：
```
输入：[7,1,5,3,6,4]
输出：7
解释：在第2天（价格=1）的时候买入，在第3天（价格=5）的时候卖出，利润 = 5-1 = 4。然后在第4天（价格=3）的时候买入，在第5天（价格=6）的时候卖出，利润 = 6-3 = 3。总利润为 4 + 3 = 7。
```

#### 解题思路

**方法：贪心算法**

只要第二天价格比今天高，就进行交易。

#### 代码实现

**Python**：
```python
def maxProfit(prices):
    profit = 0
    
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            profit += prices[i] - prices[i - 1]
    
    return profit
```

#### 复杂度分析
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)

### 题目3：柠檬水找零

**题目描述**：
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你支付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。给你一个整数数组 bills，其中 bills[i] 是第 i 位顾客支付的账单。如果你能给每位顾客正确找零，返回 true，否则返回 false。

**示例**：
```
输入：bills = [5,5,5,10,20]
输出：true
解释：
- 前3位顾客，我们按顺序收取3张5美元的钞票。
- 第4位顾客，我们收取一张10美元的钞票，并返还5美元。
- 第5位顾客，我们找还一张10美元的钞票和一张5美元的钞票。
```

#### 解题思路

**方法：贪心算法**

优先使用大面额钞票找零。

#### 代码实现

**Python**：
```python
def lemonadeChange(bills):
    five = ten = 0
    
    for bill in bills:
        if bill == 5:
            five += 1
        elif bill == 10:
            five -= 1
            ten += 1
        elif bill == 20:
            if ten > 0 and five > 0:
                ten -= 1
                five -= 1
            elif five >= 3:
                five -= 3
            else:
                return False
        
        if five < 0:
            return False
    
    return True
```

#### 复杂度分析
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)

### 题目4：根据身高重建队列

**题目描述**：
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

**示例**：
```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
```

#### 解题思路

**方法：贪心算法**

按身高降序排序，然后按ki插入到指定位置。

#### 代码实现

**Python**：
```python
def reconstructQueue(people):
    # 按身高降序，如果身高相同则按ki升序
    people.sort(key=lambda x: (-x[0], x[1]))
    
    queue = []
    for person in people:
        queue.insert(person[1], person)
    
    return queue
```

#### 复杂度分析
- **时间复杂度**：O(n²) - 插入操作是O(n)
- **空间复杂度**：O(n)

## 贪心算法的局限性

### 1. 不一定得到最优解

**示例**：找零问题

```python
# 硬币面额：1, 3, 4
# 目标金额：6

# 贪心算法
def coin_change_greedy(amount, coins):
    coins.sort(reverse=True)
    count = 0
    for coin in coins:
        count += amount // coin
        amount %= coin
    return count

coins = [1, 3, 4]
print(coin_change_greedy(6, coins))  # 3个硬币：4 + 1 + 1

# 最优解：2个硬币：3 + 3
```

### 2. 需要证明贪心选择性质

不是所有问题都适合用贪心算法，需要证明贪心选择性质和最优子结构。

## 贪心算法 vs 其他算法

### 贪心 vs 动态规划

**示例**：背包问题

```python
# 贪心算法 - 不一定最优
def knapsack_greedy(weights, values, W):
    # 计算价值密度
    items = [(values[i] / weights[i], weights[i], values[i]) 
             for i in range(len(weights))]
    items.sort(reverse=True, key=lambda x: x[0])
    
    total_value = 0
    remaining_weight = W
    
    for density, weight, value in items:
        if weight <= remaining_weight:
            total_value += value
            remaining_weight -= weight
    
    return total_value

# 动态规划 - 一定最优
def knapsack_dp(weights, values, W):
    n = len(weights)
    dp = [[0] * (W + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(1, W + 1):
            if w >= weights[i - 1]:
                dp[i][w] = max(dp[i - 1][w], 
                              dp[i - 1][w - weights[i - 1]] + values[i - 1])
    
    return dp[n][W]
```

## 常见陷阱

### 1. 贪心策略选择错误

**常见错误**：
```python
# 错误：贪心策略选择不当
def maxProfit(prices):
    # 每次都买，每次都卖
    profit = 0
    for i in range(len(prices) - 1):
        if prices[i + 1] > prices[i]:
            profit += prices[i + 1] - prices[i]
    return profit  # 对于只能交易一次的情况是错误的
```

**正确做法**：
```python
def maxProfit(prices):
    # 只能交易一次
    if not prices:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for price in prices[1:]:
        max_profit = max(max_profit, price - min_price)
        min_price = min(min_price, price)
    
    return max_profit
```

### 2. 边界条件处理

**常见错误**：
```python
# 错误：未处理空数组
def canJump(nums):
    for i in range(len(nums)):  # nums可能为空
        # ...
```

**正确做法**：
```python
def canJump(nums):
    if not nums:
        return False
    
    max_reach = 0
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
    
    return True
```

## 2025年面试趋势

### 1. 综合考察

**趋势**：
- 贪心 + 排序
- 贪心 + 栈
- 贪心 + 哈希表

### 2. 实际场景

**趋势**：
- 资源调度
- 任务分配
- 路径规划

### 3. 证明技巧

**趋势**：
- 反证法
- 交换法
- 归纳法

## 总结

贪心算法是一种简单高效的算法思想，掌握贪心算法的关键在于：

1. **理解核心思想**：局部最优选择
2. **掌握适用条件**：贪心选择性质、最优子结构
3. **熟练经典问题**：活动选择、分发饼干、跳跃游戏等
4. **注意局限性**：不一定得到最优解
5. **处理边界条件**：正确处理空数组、边界情况

**学习建议**：
- 多画图理解贪心策略
- 练习经典贪心问题
- 掌握证明技巧
- 注意时间复杂度分析

**算法系列总结**：

本系列文章涵盖了数据结构与算法的核心内容：

1. **前言**：学习路径和方法
2. **数组**：线性数据结构基础
3. **二维数组**：矩阵操作
4. **链表**：动态数据结构
5. **栈与队列**：受限线性结构
6. **树**：非线性数据结构
7. **排序算法**：数据排序
8. **查找算法**：数据检索
9. **动态规划**：优化问题
10. **贪心算法**：局部最优策略

建议继续深入学习：
- 图算法
- 字符串算法
- 高级数据结构

---

**参考资料**：
- LeetCode：https://leetcode.cn/
- 《算法导论》
- 《算法竞赛入门经典》

