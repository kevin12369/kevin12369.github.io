---
language: 'zh-CN'
title: 'Agents vs Skills - 技术范式之争'
description: '2025年10月，Anthropic发布了Claude Skills，提出了一个全新的AI能力扩展范式。与此同时，开源社区也在探索类似的方向，如Deep Agents CLI。'
publishDate: '2026-01-03'
updatedDate: 2026-01-03
tags: []
---


# Agents vs Skills - 技术范式之争

## 前言：从"工具堆砌"到"技能加载"的范式转变

2025年10月，Anthropic发布了Claude Skills，提出了一个全新的AI能力扩展范式。与此同时，开源社区也在探索类似的方向，如Deep Agents CLI。

这不仅仅是技术细节的改进，而是一场关于AI Agent如何构建和扩展的范式之争。

本文将深入分析两种范式的对比、技术原理、实际应用，以及如何选择适合的方案。

### 研究基础

本文的分析基于以下权威来源：

- **Anthropic Claude Skills官方文档**（2025年10月）
- **Deep Agents CLI开源项目**（GitHub: langchain-ai/deepagents）
- **Cornell大学论文**：AI Agents vs Agentic AI: A Conceptual Taxonomy
- **技术社区讨论**：关于Agents vs Skills的广泛讨论

## 第一部分：两种范式的对比

### 1.1 Agent范式：自主性 + 工具堆砌

**核心理念：**
通过给AI Agent提供大量工具（Tools），让Agent自主选择和使用这些工具来完成任务。

**典型特征：**
- 自主性强：Agent可以自主决策
- 工具丰富：提供大量预定义工具
- 灵活性高：可以处理各种任务

**技术架构：**
```
AI Agent
  ↓
工具列表（数百个工具）
  ↓
工具选择器
  ↓
工具执行
  ↓
结果整合
```

**优势：**
1. **通用性强**：可以处理各种类型的任务
2. **自主决策**：Agent可以自主选择合适的工具
3. **灵活性高**：可以动态组合不同工具

**劣势：**
1. **Token消耗大**：所有工具的元数据都需要加载到上下文
2. **认知负担重**：Agent需要在大量工具中进行选择
3. **可预测性差**：自主决策可能导致不确定性
4. **维护成本高**：工具数量越多，维护越复杂

### 1.2 Skills范式：确定性 + 渐进加载

**核心理念：**
通过模块化的技能（Skills），按需加载AI的能力，实现高效、可预测的AI行为。

**典型特征：**
- 确定性强：Skills的行为是预定义的
- 渐进加载：按需加载，节省Token
- 模块化：Skills可以组合和复用

**技术架构：**
```
AI Agent
  ↓
技能元数据（始终加载，<100 tokens）
  ↓
技能匹配
  ↓
技能指令（按需加载）
  ↓
技能资源（执行时加载）
  ↓
结果输出
```

**优势：**
1. **Token效率高**：渐进式加载，节省95%的Token
2. **可预测性强**：Skills的行为是预定义的
3. **可维护性好**：模块化设计，易于维护
4. **可复用性强**：Skills可以组合和复用

**劣势：**
1. **灵活性受限**：需要预先定义Skills
2. **自主性降低**：Agent的自主决策能力受限
3. **设计复杂度高**：需要精心设计Skills

### 1.3 核心差异总结

| 维度 | Agent范式 | Skills范式 |
|------|-----------|------------|
| **核心思想** | 工具堆砌 | 技能加载 |
| **自主性** | 高 | 中 |
| **确定性** | 低 | 高 |
| **Token效率** | 低 | 高 |
| **维护成本** | 高 | 中 |
| **灵活性** | 高 | 中 |
| **适用场景** | 通用任务 | 特定任务 |
| **学习曲线** | 陡 | 中 |

## 第二部分：Claude Skills的技术原理

### 2.1 核心概念

**定义：**
Claude Skills是扩展Claude功能的模块化能力。每个Skill包含元数据、指令和资源，Claude会在相关时自动调用，无需编写代码。

**与MCP的区别：**
- **MCP（Model Context Protocol）**：是一种协议，用于在不同系统之间传递上下文
- **Skills**：是一种能力模块，用于扩展AI的功能

**典型应用场景：**
- 数据报告生成
- PDF处理
- 演示文稿创建
- 文档编写

### 2.2 渐进式披露架构

**核心创新：**
按需分阶段加载，而非预先消耗上下文。

**三层加载机制：**

**第一层：元数据（始终加载，<100 tokens）**
```yaml
---
name: pdf-processing
description: 提取PDF文本和表格。在用户上传PDF时使用。
---
```

**第二层：指令（触发时加载）**
```markdown
## 何时使用
- 用户上传PDF文件
- 需要提取文本或表格

## 步骤
1. 使用pdfextract.py提取内容
2. 解析表格结构
3. 格式化输出
```

**第三层：资源（执行时加载）**
```
skills/pdf-processing/
├── SKILL.md          # 第1、2层
├── pdfextract.py      # 第3层
└── tableparser.py     # 第3层
```

**执行流程：**
```
用户输入
  ↓
Claude理解意图
  ↓
第1层：检查元数据（所有Skills已在内存）
  ↓
第2层：加载相关Skills的指令（按需）
  ↓
第3层：加载Skills的资源（执行时）
  ↓
执行任务
  ↓
输出结果
```

### 2.3 Token效率提升

**数据对比：**

**传统方式（工具堆砌）：**
- 所有工具的元数据：约10,000 tokens
- 每次请求都加载：10,000 tokens
- Token消耗：10,000 tokens/请求

**Claude Skills方式（渐进加载）：**
- 所有Skills的元数据：<1,000 tokens
- 相关Skills的指令：约500 tokens
- 相关Skills的资源：约2,000 tokens
- Token消耗：<3,500 tokens/请求

**效率提升：**
- 节省Token：约65%
- 对于复杂任务，可节省高达95%

### 2.4 核心优势

#### 1. 即插即用

**特点：**
- 自动识别调用
- 零学习成本
- 无需编写代码

**示例：**
```
用户："帮我提取这个PDF中的表格"
Claude：自动调用pdf-processing Skill
```

#### 2. 渐进加载

**特点：**
- 按需消耗tokens
- 高效节约
- 支持大量Skills

**示例：**
```
不相关的Skills：不加载
相关的Skills：按需加载
执行时：加载资源
```

#### 3. 确定性执行

**特点：**
- 代码运行非推理
- 100%准确
- 可预测的结果

**示例：**
```
Skill：使用Python脚本提取PDF
结果：100%准确，无幻觉
```

#### 4. 沙箱隔离

**特点：**
- 安全环境运行
- 可信可靠
- 隔离风险

**示例：**
```
Skill在沙箱中执行
不影响主系统
```

## 第三部分：Deep Agents的实践

### 3.1 从Tool到Skill的转变

**核心思想：**
把"动作"从Tool卸载到文件系统。

**传统方式（Tool）：**
```
每个操作一个Tool
- readFile Tool
- writeFile Tool
- executeCommand Tool
- ...
```

**新方式（Skill）：**
```
文件系统作为通用工具
- bash Tool
- filesystem Tools
- 通过Skills组织能力
```

### 3.2 文件系统作为通用工具

**核心概念：**
Agent不再依赖数百个定制工具，而是被赋予一台"电脑"。

**能力：**
- 读文件
- 写文件
- 写脚本
- 跑命令

**优势：**
- 工具数量少
- 灵活性高
- 接近人类开发者

### 3.3 能力迁移而非工具升级

**核心区别：**
- Skills不是Tools的升级
- Skills是一种新的能力组织方式
- Skills强调能力的迁移和复用

**示例：**
```
Tool：一个特定的功能
Skill：一个可复用的能力模块

Tool：readFile
Skill：文件处理能力（包含read、write、parse等）
```

### 3.4 实际应用

**Deep Agents CLI项目：**
- GitHub: langchain-ai/deepagents
- 开源的Skills实现
- 展示了从Tool到Skill的转变

**关键技术：**
- 文件系统作为通用工具
- Skills的组织和加载
- 渐进式披露架构

## 第四部分：批判性分析

### 4.1 何时用Agent？

**适用场景：**

1. **通用任务**
   - 任务类型不确定
   - 需要灵活处理
   - 需要自主决策

2. **探索性任务**
   - 需要尝试多种方法
   - 需要动态调整策略
   - 需要创造性解决方案

3. **复杂任务**
   - 需要多步骤处理
   - 需要动态组合工具
   - 需要自主规划

**示例：**
```
任务：研究一个新技术并生成报告
方式：使用Agent范式
原因：需要自主探索、动态调整
```

### 4.2 何时用Skills？

**适用场景：**

1. **特定任务**
   - 任务类型明确
   - 需要确定性结果
   - 需要高效率

2. **重复性任务**
   - 需要多次执行
   - 需要一致性
   - 需要可复用

3. **性能敏感任务**
   - Token消耗敏感
   - 响应时间敏感
   - 成本敏感

**示例：**
```
任务：处理PDF文件
方式：使用Skills范式
原因：任务明确，需要确定性和高效率
```

### 4.3 混合模式的可能

**核心理念：**
结合Agent和Skills的优势，构建更强大的AI系统。

**架构设计：**
```
AI Agent（自主决策）
  ↓
Skills模块（确定性执行）
  ↓
工具层（底层能力）
```

**优势：**
1. **灵活性 + 确定性**：Agent提供灵活性，Skills提供确定性
2. **自主性 + 效率**：Agent自主决策，Skills高效执行
3. **通用性 + 专用性**：Agent处理通用任务，Skills处理专用任务

**示例：**
```
任务：开发一个完整的电商系统

Agent：
- 分析需求
- 设计架构
- 规划开发步骤

Skills：
- 用户认证Skill
- 商品管理Skill
- 订单处理Skill
- 支付集成Skill

执行：
Agent调用Skills完成具体任务
```

### 4.4 选择指南

**决策树：**

```
任务类型明确？
├─ 是 → 需要确定性？
│   ├─ 是 → 使用Skills
│   └─ 否 → 考虑混合模式
└─ 否 → 需要自主决策？
    ├─ 是 → 使用Agent
    └─ 否 → 使用Skills
```

**选择建议：**

1. **简单、明确的任务** → Skills
2. **复杂、不确定的任务** → Agent
3. **需要确定性和效率的任务** → Skills
4. **需要灵活性和创造性的任务** → Agent
5. **大型、复杂的项目** → 混合模式

## 第五部分：实际案例

### 5.1 案例1：PDF处理系统

**需求：**
提取PDF文件中的文本和表格，生成结构化数据。

**方案A：使用Agent范式**
```
Agent + Tools：
- PDF读取Tool
- 文本提取Tool
- 表格解析Tool
- 数据格式化Tool

问题：
- Token消耗大
- 工具选择复杂
- 结果不确定
```

**方案B：使用Skills范式**
```
Skills：
- pdf-processing Skill
  - 元数据：描述Skill
  - 指令：处理步骤
  - 资源：Python脚本

优势：
- Token效率高
- 结果确定
- 易于维护
```

**对比：**
| 指标 | Agent范式 | Skills范式 |
|------|-----------|------------|
| Token消耗 | 8,000 | 2,500 |
| 准确率 | 85% | 99% |
| 维护成本 | 高 | 低 |
| 开发时间 | 2周 | 3天 |

**结论：** 对于这个明确的任务，Skills范式更合适。

### 5.2 案例2：智能客服系统

**需求：**
处理用户咨询，提供智能回复，支持多轮对话。

**方案A：使用Agent范式**
```
Agent + Tools：
- 对话管理Tool
- 知识库查询Tool
- 意图识别Tool
- 回复生成Tool

优势：
- 灵活性高
- 自主决策
- 适应性强
```

**方案B：使用Skills范式**
```
Skills：
- 意图识别Skill
- 知识库查询Skill
- 回复生成Skill

问题：
- 灵活性受限
- 需要预定义
- 难以适应新场景
```

**对比：**
| 指标 | Agent范式 | Skills范式 |
|------|-----------|------------|
| 灵活性 | 高 | 中 |
| 准确率 | 75% | 90% |
| 维护成本 | 高 | 低 |
| 开发时间 | 3周 | 2周 |

**结论：** 对于这个需要灵活性和适应性的任务，Agent范式更合适。

### 5.3 案例3：代码生成与审查系统

**需求：**
生成代码，进行代码审查，提供改进建议。

**方案：混合模式**
```
Agent：
- 分析需求
- 设计架构
- 规划生成步骤

Skills：
- 代码生成Skill
- 代码审查Skill
- 测试生成Skill
- 文档生成Skill

执行：
1. Agent分析需求
2. Agent调用代码生成Skill
3. Agent调用代码审查Skill
4. Agent整合结果
```

**优势：**
1. Agent提供灵活性和自主性
2. Skills提供确定性和效率
3. 结合两者的优势

**对比：**
| 指标 | 纯Agent | 纯Skills | 混合模式 |
|------|---------|----------|----------|
| 灵活性 | 高 | 低 | 高 |
| 效率 | 低 | 高 | 高 |
| 准确率 | 70% | 95% | 92% |
| 维护成本 | 高 | 低 | 中 |

**结论：** 对于这个复杂的任务，混合模式最佳。

## 第六部分：最佳实践

### 6.1 设计Skills的准则

#### 1. 单一职责

**原则：**
每个Skill只负责一个明确的功能。

**示例：**
```
❌ 错误：文件处理Skill（包含读、写、解析等）
✅ 正确：PDF读取Skill、表格解析Skill、数据格式化Skill
```

#### 2. 明确的元数据

**原则：**
元数据应该清晰、简洁、准确。

**示例：**
```yaml
---
name: pdf-processing
description: 提取PDF文本和表格。在用户上传PDF时使用。
version: 1.0.0
author: Your Name
---
```

#### 3. 清晰的指令

**原则：**
指令应该详细、可执行、无歧义。

**示例：**
```markdown
## 何时使用
- 用户上传PDF文件
- 需要提取文本或表格

## 步骤
1. 使用pdfextract.py提取内容
2. 解析表格结构
3. 格式化输出

## 输出格式
- JSON格式
- 包含文本和表格数据
```

#### 4. 可测试的资源

**原则：**
资源应该独立、可测试、可维护。

**示例：**
```
skills/pdf-processing/
├── SKILL.md
├── pdfextract.py      # 可独立测试
├── tableparser.py     # 可独立测试
└── test/              # 测试用例
    ├── test_pdfextract.py
    └── test_tableparser.py
```

### 6.2 构建Agent的准则

#### 1. 明确的目标

**原则：**
Agent应该有明确的目标和范围。

**示例：**
```
❌ 错误：万能Agent（什么都能做）
✅ 正确：代码审查Agent（专注于代码审查）
```

#### 2. 合理的工具选择

**原则：**
选择合适的工具，避免工具堆砌。

**示例：**
```
❌ 错误：提供100+个工具
✅ 正确：提供10-20个核心工具
```

#### 3. 清晰的工作流

**原则：**
Agent的工作流应该清晰、可理解、可维护。

**示例：**
```
1. 分析需求
2. 选择工具
3. 执行任务
4. 验证结果
5. 输出结果
```

### 6.3 混合模式的设计

#### 1. 明确的分工

**原则：**
Agent负责决策和规划，Skills负责执行。

**示例：**
```
Agent：
- 分析需求
- 选择Skills
- 规划执行步骤

Skills：
- 执行具体任务
- 返回确定结果
```

#### 2. 合理的接口

**原则：**
Agent和Skills之间的接口应该清晰、简单、稳定。

**示例：**
```python
# Agent调用Skill
result = agent.call_skill(
    skill_name="pdf-processing",
    input={"file": "document.pdf"}
)
```

#### 3. 错误处理

**原则：**
应该有完善的错误处理机制。

**示例：**
```
1. Agent捕获Skill错误
2. 分析错误原因
3. 尝试恢复或回退
4. 记录错误信息
```

## 第七部分：未来展望

### 7.1 技术发展趋势

#### 1. Skills生态成熟

**趋势：**
- Skills平台化
- Skills市场化
- Skills标准化

**影响：**
- Skills将成为AI应用的基本构建块
- Skills市场将繁荣
- Skills标准将建立

#### 2. Agent智能化

**趋势：**
- Agent自主性增强
- Agent学习能力提升
- Agent协作能力提升

**影响：**
- Agent将更智能
- Agent将更自主
- Agent将更协作

#### 3. 混合模式普及

**趋势：**
- Agent + Skills成为主流
- 平台支持混合模式
- 最佳实践建立

**影响：**
- AI系统将更强大
- AI应用将更高效
- AI开发将更简单

### 7.2 面临的挑战

#### 1. 技术挑战

**Skills挑战：**
- Skills设计复杂度高
- Skills互操作性问题
- Skills标准化困难

**Agent挑战：**
- Agent可控性问题
- Agent可预测性问题
- Agent安全性问题

#### 2. 工程挑战

**Skills挑战：**
- Skills测试困难
- Skills维护成本高
- Skills版本管理复杂

**Agent挑战：**
- Agent调试困难
- Agent监控复杂
- Agent优化困难

#### 3. 生态挑战

**Skills挑战：**
- Skills生态不成熟
- Skills市场不完善
- Skills社区不活跃

**Agent挑战：**
- Agent标准不统一
- Agent平台碎片化
- Agent工具不完善

### 7.3 发展建议

#### 1. 对于开发者

**Skills：**
- 学习Skills设计
- 掌握Skills最佳实践
- 参与Skills社区

**Agent：**
- 学习Agent开发
- 掌握Agent工作流
- 参与Agent开源项目

**混合模式：**
- 理解混合模式
- 掌握混合设计
- 实践混合应用

#### 2. 对于企业

**Skills：**
- 建立Skills库
- 制定Skills标准
- 培养Skills团队

**Agent：**
- 建立Agent平台
- 制定Agent规范
- 培养Agent团队

**混合模式：**
- 建立混合架构
- 制定混合规范
- 培养混合团队

#### 3. 对于社区

**Skills：**
- 建立Skills市场
- 制定Skills标准
- 促进Skills共享

**Agent：**
- 建立Agent社区
- 制定Agent规范
- 促进Agent协作

**混合模式：**
- 建立混合生态
- 制定混合标准
- 促进混合创新

## 总结：范式之争的启示

Agents vs Skills不是简单的技术选择，而是两种不同的AI构建范式。

**核心观点：**

1. **没有绝对的优劣**
   - Agent适合灵活、不确定的任务
   - Skills适合明确、确定的任务
   - 混合模式结合两者优势

2. **选择取决于场景**
   - 任务类型
   - 性能要求
   - 维护成本
   - 开发时间

3. **未来是混合的**
   - Agent提供灵活性和自主性
   - Skills提供确定性和效率
   - 混合模式将成为主流

**实践建议：**

1. **理解两种范式**
   - 学习Agent开发
   - 学习Skills设计
   - 理解混合模式

2. **根据场景选择**
   - 简单任务用Skills
   - 复杂任务用Agent
   - 大型项目用混合

3. **持续学习和优化**
   - 关注技术发展
   - 学习最佳实践
   - 优化设计方案

## 参考文献

1. Anthropic - Claude Skills Official Documentation (2025)
2. Deep Agents CLI - GitHub: langchain-ai/deepagents
3. Cornell University - "AI Agents vs. Agentic AI: A Conceptual Taxonomy, Applications and Challenges"
4. 技术社区讨论 - Agents vs Skills
5. 开源项目案例

---

**系列文章导航：**
1. AI增强型全栈开发者的技术定位与能力模型
2. 全栈开发的技术演进：从工具时代到智能体时代
3. AI编程效率的实证研究：从神话到现实
4. Agents vs Skills - 技术范式之争（本文）
5. Vibe Coding的批判性分析
6. Claude Skills深度解析
7. AI工具链的工程化实践
8. 企业级AI应用的最佳实践
9. AI时代的系统设计思维
10. Prompt Engineering的工程化方法
11. AI Agent的记忆与上下文管理
12. 2026-2030技术趋势大胆预测与多方向展望