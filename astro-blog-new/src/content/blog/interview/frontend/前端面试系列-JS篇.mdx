---
language: 'zh-CN'
title: 'JavaScript 常见面试题总结（2025版）'
description: '参考自掘金《2023 前端面试系列-- JS 篇》'
publishDate: '2024-01-01'
tags: ['JavaScript', '面试', 'ES6']
---

import { Card, Label, Collapse } from 'astro-pure/user'

## 前言

本文总结了JavaScript相关的常见面试题,涵盖2025年最新的技术趋势和高频考点,帮助前端开发者系统复习JavaScript基础知识。

[参考自掘金《2023 前端面试系列-- JS 篇》](https://juejin.cn/post/7176644710847479869)

## 2025年JavaScript面试趋势

<Card>
- **ES6+ 新特性深入**：不再局限于基本语法，而是深入理解原理和应用场景
- **异步编程进阶**：Promise、async/await、Event Loop 的深入理解
- **函数式编程**：高阶函数、纯函数、不可变性、函数组合
- **模块化**：ES Modules、CommonJS、AMD 的对比和应用
- **性能优化**：内存管理、垃圾回收、V8 引擎原理
- **TypeScript 融合**：类型系统在 JavaScript 中的应用
</Card>

## 数据类型

<Collapse title="参考链接">
[参考自掘金《2023 前端面试系列-- JS 篇》](https://juejin.cn/post/7176644710847479869)
</Collapse>

### JS 的数据类型有哪些？

- **基本数据类型（值类型）**：
  - `Number`：数字（整数、浮点数）
  - `String`：字符串
  - `Boolean`：布尔值
  - `Null`：空值
  - `Undefined`：未定义
  - `Symbol`：唯一标识符（ES6）
  - `BigInt`：大整数（ES2020）

- **复杂数据类型（引用类型）**：
  - `Object`：对象
  - `Array`：数组
  - `Function`：函数
  - `Date`：日期
  - `RegExp`：正则表达式
  - `Map`、`Set`、`WeakMap`、`WeakSet`（ES6）

**存储方式**：
- 基本数据类型：保存在栈内存中，可以直接访问它的值
- 引用数据类型：保存在堆内存中，栈内存中保存的是地址，通过栈中的地址去访问堆中的值

### null 和 undefined 的区别？

- **null**：
  - 表示一个对象被定义了，值为"空值"
  - 是一个表示"无"的对象
  - 转换为数字时为 `0`
  - 用法：
    - 作为函数的参数，表示该函数的参数不是对象
    - 作为对象原型链的终点

- **undefined**：
  - 表示不存在这个值
  - 是一个表示"未定义"的原始值
  - 转换为数字时为 `NaN`
  - 用法：
    - 函数没有返回值时，默认返回 `undefined`
    - 变量已声明，没有赋值时，为 `undefined`
    - 对象中没有赋值的属性，该属性的值为 `undefined`
    - 调用函数时，应该提供的参数没有提供，该参数等于 `undefined`

### 如何判断 JS 的数据类型？

1. **typeof**：
   - 可以区分除了 `Null` 类型以外的其他基本数据类型
   - 可以识别出函数
   - 返回值：`number`、`string`、`boolean`、`undefined`、`symbol`、`bigint`、`function`、`object`
   - 注意：`typeof null` 返回 `"object"`（历史遗留问题）

   ```javascript
   typeof 1 // 'number'
   typeof '1' // 'string'
   typeof true // 'boolean'
   typeof undefined // 'undefined'
   typeof Symbol() // 'symbol'
   typeof null // 'object'
   typeof [] // 'object'
   typeof {} // 'object'
   typeof console // 'object'
   typeof console.log // 'function'
   ```

2. **instanceof**：
   - 一般用来判断引用数据类型
   - 不能正确判断基本数据类型
   - 根据原型链中查找判断当前数据的原型对象是否存在
   - 返回布尔值

   ```javascript
   1 instanceof Number; // false
   true instanceof Boolean; // false
   'str' instanceof String; // false
   [] instanceof Array; // true
   function(){} instanceof Function; // true
   {} instanceof Object; // true
   let date = new Date();
   date instanceof Date; // true
   ```

3. **Object.prototype.toString**：
   - 最准确的数据类型判断方法
   - 可以判断所有数据类型

   ```javascript
   Object.prototype.toString({}) // "[object Object]"
   Object.prototype.toString.call({}) // "[object Object]"
   Object.prototype.toString.call(1) // "[object Number]"
   Object.prototype.toString.call('1') // "[object String]"
   Object.prototype.toString.call(true) // "[object Boolean]"
   Object.prototype.toString.call(function () {}) // "[object Function]"
   Object.prototype.toString.call(null) // "[object Null]"
   Object.prototype.toString.call(undefined) // "[object Undefined]"
   Object.prototype.toString.call(/123/g) // "[object RegExp]"
   Object.prototype.toString.call(new Date()) // "[object Date]"
   Object.prototype.toString.call([]) // "[object Array]"
   Object.prototype.toString.call(document) // "[object HTMLDocument]"
   Object.prototype.toString.call(window) // "[object Window]"
   ```

4. **Array.isArray**：
   - 专门用于判断数组

   ```javascript
   Array.isArray([]) // true
   Array.isArray({}) // false
   Array.isArray(1) // false
   Array.isArray('string') // false
   Array.isArray(true) // false
   ```

5. **2025年新增考点**：
   <Label>新增考点</Label>
   - `Object.prototype.toString` 的原理
   - 如何实现一个通用的类型判断函数？

### == 和 === 的区别？

- **==（宽松相等）**：
  - 两个等号称为等值符
  - 当等号两边的值为相同类型时，比较值是否相同
  - 类型不同时会发生隐式类型转换，转换为相同的类型后再做比较
  - 转换规则：
    - `null == undefined` → `true`
    - `string == number` → string 转换为 number
    - `boolean == any` → boolean 转换为 number
    - `object == string | number | symbol` → 对象转换为原始值

- **===（严格相等）**：
  - 三个等号称为等同符
  - 当等号两边的值为相同类型时，直接比较值
  - 值相同则返回 `true`
  - 若等号两边值的类型不同时直接返回 `false`
  - 不发生类型转换

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- 为什么推荐使用 `===`？
- `Object.is()` 和 `===` 的区别（处理 `NaN` 和 `+0/-0`）

## 作用域和闭包

### JS 中的作用域和作用域链？

**作用域**：变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。作用域决定了代码区块中变量和其他资源的可见性。

- **全局作用域**：
  - 任何不在函数中或者是大括号中声明的变量，都是在全局作用域下
  - 全局作用域下声明的变量可以在程序的任意位置访问
  - 浏览器环境中，`window` 对象代表全局作用域

- **局部作用域（函数作用域）**：
  - 如果一个变量是在函数内部声明的，它就在一个函数作用域下面
  - 这些变量只能在函数内部访问，不能在函数以外去访问

- **块级作用域**：
  - 凡是代码块就可以划分变量的作用域
  - ES6 新增 `let` 和 `const` 支持块级作用域
  - 使用 `var` 声明的变量不具有块级作用域

**作用域链**：
- 当在 JS 中使用一个变量时，JS 引擎会尝试在当前作用域下寻找该变量
- 如果没找到，再到它的上层作用域寻找
- 以此类推，直至找到该变量或是查找至全局作用域
- 如果在全局作用域里仍然找不到该变量，它就会报错（严格模式下）

**重要**：
- JS 采用的是**静态作用域**（词法作用域）
- 函数的作用域在函数定义时就确定了，而不是在调用时确定

推荐阅读：[JavaScript 深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)

### JS 的预解析？

<Card>
JS 代码的执行是由浏览器中的 JS 解析器来执行的，JS 解析器执行 JS 代码时，分为两个过程：**预解析过程**和**代码执行过程**。

预解析分为**变量预解析（变量提升）**和**函数预解析（函数提升）**。

- **变量提升**：
  - 把变量的声明提升到当前作用域的最前面
  - 只提升声明，不提升赋值

- **函数提升**：
  - 把函数的声明提升到当前作用域的最前面
  - 只提升声明，不提升调用

**注意**：
- 函数表达式的写法不存在函数提升
- 函数提升优先级高于变量提升
- 函数提升在变量提升之上，且不会被同名变量声明时覆盖
- 但是会被同名变量赋值后覆盖

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- `let` 和 `const` 是否存在变量提升？（存在，但有暂时性死区 TDZ）
- 理解"暂时性死区"（Temporal Dead Zone）
</Card>

### 闭包？

<Card>
**定义**：
- 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来
- 可以在一个内层函数中访问到其外层函数的作用域
- 闭包就是能够读取其他函数内部变量的函数

**作用**：
- 解决变量污染问题
- 延长局部变量的生命周期
- 实现数据私有化

**优点**：
- 延长局部变量的生命周期
- 实现数据私有化
- 模块化编程

**缺点**：
- 会导致函数的变量一直保存在内存中
- 过多的闭包可能会导致内存泄漏

**应用场景**：
- 柯里化（Currying）
- 函数防抖和节流
- 模块模式
- 事件委托

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- 闭包的内存泄漏问题及解决方案
- 如何避免闭包导致的内存泄漏？
- 闭包在 React Hooks 中的应用
</Card>

推荐阅读：[我从来不理解 JavaScript 闭包，直到有人这样向我解释它](https://juejin.cn/post/6844903858636849159)

## 原型和原型链

### 原型和原型链？

**原型**：
- JS 是面向对象的，每个实例对象都有一个 `__proto__` 属性，该属性指向它的**原型**对象
- 该实例的构造函数有一个原型属性 `prototype`，与实例的 `__proto__` 属性指向同一个对象
- 原型对象的 `constructor` 指向构造函数本身

[对象原型](./images/对象原型.png '对象原型')

**原型链**：
- 当一个对象在查找一个属性时，自身没有就会根据 `__proto__` 属性向它的**原型**进行查找
- 如果还是没有，则向它的**原型的原型**继续查找
- 直至查到 `Object.prototype.__proto__` 也就是 `null`
- 这样就形成了**原型链**

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- 原型链的终点是什么？（`null`）
- 如何判断一个属性是对象自身的还是原型上的？（`hasOwnProperty`）
- 如何实现继承？（原型链继承、构造函数继承、组合继承、寄生组合继承）

推荐阅读：[轻松理解 JS 原型和原型链](https://juejin.cn/post/6844903989088092174)

## this

### this 的理解？

1. **概念**：
   - `this` 是 JS 的一个关键字
   - 它是函数运行时，自动生成的一个内部对象
   - 只能在函数内部使用
   - 随着函数使用场合的不同，`this` 的值会发生变化
   - 总原则：**this 指的是调用函数的那个对象**

2. **this 的指向**：
   - **作为普通函数执行时**：
     - `this` 指向 `window`（非严格模式）
     - `this` 指向 `undefined`（严格模式）

   - **函数作为对象里的方法被调用时**：
     - `this` 指向该对象

   - **当用 `new` 运算符调用构造函数时**：
     - `this` 指向返回的这个对象

   - **箭头函数的 `this`**：
     - 不绑定 `this`，会捕获其所在上下文的 `this`，作为自己的 `this`
     - `this` 绑定看的是 `this` 所在函数定义在哪个对象下，就绑定哪个对象
     - 如果存在嵌套，则 `this` 绑定到最近的一层对象上

   - **`call()`、`apply()`、`bind()`**：
     - 可以显式地指定调用函数的 `this` 指向

3. **2025年高频考点**：
   <Label color="purple">高频考点</Label>
   - 箭头函数的 `this` 特性
   - 如何改变 `this` 的指向？
   - React 事件处理中的 `this` 绑定问题

## call、apply、bind

### call、apply、bind 的区别以及手写实现？

**共同点**：
- 改变函数执行时的上下文，简而言之就是改变函数运行时的 `this` 指向

**区别**：

1. **`call()`**：
   - 可以传递两个参数，第一个参数是指定函数内部中 `this` 的指向
   - 第二个参数是函数调用时需要传递的参数（列表形式）
   - 改变 `this` 指向后原函数会立即执行
   - 此方法只是临时改变 `this` 指向一次

   ```js
   // 手写实现
   Function.prototype.myCall = function (context) {
     // 判断调用对象
     if (typeof this != 'function') {
       throw new Error('type error')
     }
     // 首先获取参数
     let args = [...arguments].slice(1)
     let res = null
     // 将被调用的方法置入 context 的属性
     // this 即为要调用的方法
     context.fn = this
     // 执行要被调用的方法
     res = context.fn(...args)
     // 删除手动增加的属性方法
     delete context.fn
     // 执行结果返回
     return res
   }
   ```

2. **`apply()`**：
   - 接受两个参数，第一个参数是 `this` 的指向
   - 第二个参数是函数接受的参数，以**数组**的形式传入
   - 改变 `this` 指向后原函数会立即执行
   - 此方法只是临时改变 `this` 指向一次

   ```js
   // 手写实现
   Function.prototype.myApply = function (context) {
     if (typeof this != 'function') {
       throw new Error('type error')
     }
     let res = null
     context = context || window
     // 使用 symbol 来保证属性唯一
     // 也就是保证不会重写用户自己原来定义在 context 中的同名属性
     const fnSymbol = Symbol()
     context[fnSymbol] = this
     // 执行被调用的方法
     if (arguments[1]) {
       res = context[fnSymbol](...arguments[1])
     } else {
       res = context[fnSymbol]()
     }
     delete context[fnSymbol]
     return res
   }
   ```

3. **`bind()`**：
   - 第一个参数也是 `this` 的指向
   - 后面传入的也是一个参数列表（但是这个参数列表可以分多次传入）
   - 改变 `this` 指向后**不会立即执行**
   - 而是返回一个永久改变 `this` 指向的函数

   ```js
   // 手写实现
   Function.prototype.myBind = function (context) {
     if (typeof this != 'function') {
       throw new Error('type error')
     }
     let args = [...arguments].slice(1)
     const fn = this
     return function Fn() {
       return fn.apply(this instanceof Fn ? this : context, args.concat(...arguments))
     }
   }
   ```

**总结**：
- `call()` 和 `bind()` 第二个参数是列表形式的
- `apply()` 第二个参数是数组形式
- `call()` 和 `apply()` 是立即执行
- `bind()` 不会立即执行而是生成一个修改 `this` 之后的新函数

## 箭头函数

### 箭头函数？

1. **定义**：
   - 箭头函数是定义函数一种新的方式，比普通函数定义更加方便和简单

2. **特点**：
   - 箭头函数不绑定 `this`，会捕获其所在上下文的 `this`，作为自己的 `this`
   - 箭头函数不能用作构造函数，也就是说不可以使用 `new` 命令，否则会抛出错误
   - 箭头函数不绑定 `arguments`，取而代之用 `rest` 参数解决
   - 箭头函数没有 `super` 和 `new.target`
   - 使用 `call`、`apply`、`bind` 并不会改变箭头函数中的 `this` 指向
   - 对箭头函数使用 `call` 或 `apply` 方法时，只会传入参数并调用函数
   - 对箭头函数使用 `bind` 方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的 `this` 指向

3. **2025年高频考点**：
   <Label color="purple">高频考点</Label>
   - 箭头函数的适用场景
   - 箭头函数的局限性
   - 箭头函数与普通函数的区别

## 深浅拷贝

### 浅拷贝和深拷贝的实现？

**浅拷贝**：
- 如果属性是基本类型，拷贝的就是基本类型的值
- 如果属性是引用类型，拷贝的就是内存地址
- 即浅拷贝是**拷贝一层**，深层次的引用类型则共享内存地址
- 常用的方法：`Object.assign`、扩展运算符等

```js
var a = { count: 1, deep: { count: 2 } }
var b = Object.assign({}, a)
// 或
var c = { ...a }

// 手动实现
function shallowClone(obj) {
  const newObj = {}
  for (let prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      newObj[prop] = obj[prop]
    }
  }
  return newObj
}
```

**深拷贝**：
- 开辟一个新的栈，两个对象的属性完全相同，但是对应两个不同的地址
- 修改一个对象的属性，不会改变另一个对象的属性

```js
/**
 * 深拷贝
 * @param {object} obj 要拷贝的对象
 * @param {Map} map 用于存储循环引用对象的地址
 */
function deepClone(obj = {}, map = new Map()) {
  if (obj === null) return obj // 如果是 null 或者 undefined 我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝
  if (typeof obj !== 'object') return obj
  if (map.get(obj)) {
    return map.get(obj)
  }
  let result = {} // 初始化返回的值
  // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此
  if (obj instanceof Array || Object.prototype.toString.call(obj) === '[object Array]') {
    return (result = [])
  }
  // 防止循环引用
  map.set(obj, result)
  for (const key in obj) {
    // 保证 key 不是原型属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key], map)
    }
  }
  return result
}
```

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- 如何实现一个完美的深拷贝？（考虑循环引用、特殊对象、函数等）
- `JSON.parse(JSON.stringify())` 的局限性
- 结构化克隆（Structured Clone）API

## 内存管理

### JavaScript 中内存泄漏的几种情况？

内存泄漏一般是指系统进程不再用到的内存，没有及时释放，造成内存资源的浪费，导致程序运行速度慢甚至崩溃等严重后果。

**造成内存泄漏的原因有：**

1. **全局变量**：
   - 在局部作用域中，函数执行完毕后，变量就没有存在的必要了，垃圾回收机制很快的做出判断并回收
   - 但是对于全局变量，很难判断什么时候不用这些变量，无法正常回收
   - **解决办法**：
     - 尽量少使用全局变量
     - 使用严格模式，在 js 文件头部或者函数的顶部加上 `'use strict'`

2. **闭包引起的内存泄漏**：
   - 闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中
   - 如果在使用结束后没有将局部变量清除，就可能导致内存泄漏
   - **解决办法**：将事件处理函数定义在外部，解除闭包

3. **被遗忘的定时器**：
   - 定时器 `setInterval` 或者 `setTimeout` 不再需要使用时，且没有被清除
   - 导致定时器的回调函数及其内部依赖的变量都不能被回收，就会造成内存泄漏
   - **解决办法**：当不需要定时器的时候，调用 `clearInterval` 或者 `clearTimeout` 手动清除

4. **事件监听**：
   - 垃圾回收机制不好判断事件是否需要被解除，导致 `callback` 不能被释放
   - **解决办法**：及时使用 `removeEventListener` 移除事件监听

5. **元素引用没有清理**：
   - **解决办法**：移除元素后，手动设置元素的引用为 `null`

6. **console**：
   - 传递给 `console.log` 的对象是不能被垃圾回收，可能会存在内存泄漏
   - **解决办法**：清除不必要的 `console`

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- V8 引擎的垃圾回收机制（分代回收、标记清除、标记整理）
- 如何检测内存泄漏？（Chrome DevTools）
- WeakMap 和 WeakSet 的应用场景

## 防抖和节流

### 防抖和节流的区别，以及手写实现？

**防抖**：
- 多次触发事件，事件处理函数只执行一次，并且是在触发操作结束时执行
- 当一个事件被触发，准备执行事件函数前，会等待一定的时间
- 在这个等待时间内，如果没有再次被触发，那么就执行这个事件函数
- 如果又触发了，那么本次动作作废，重置等待时间，直到最终能执行为止

**主要应用场景**：
- 搜索框搜索输入，用户最后一次输入完成后，再发送请求
- 手机号、邮箱验证输入检测

**节流**：
- 事件触发后，规定时间内，事件处理函数不能再次被调用
- 也就是说在规定的时间内，函数只能被调用一次，而且是最先被触发的那次

**主要应用场景**：
- 高频点击
- 表单重复提交
- 滚动事件

```js
/**
 * 防抖函数
 * @param func 要被防抖的函数
 * @param wait 规定的时间
 */
function debounce(func, wait) {
  let timeout
  return function () {
    let context = this // 保持 this 指向
    let args = arguments // 拿到 event 对象

    clearTimeout(timeout) // 清除定时器，释放内存
    timeout = setTimeout(function () {
      func.apply(context, args)
    }, wait)
  }
}

/**
 * 节流函数
 * @param fn 要被节流的函数
 * @param wait 规定的时间
 */
function throttled(fn, wait) {
  let timer = null
  return function (...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, wait)
    }
  }
}
```

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- 防抖和节流的区别
- 如何实现一个立即执行的防抖？
- 如何实现一个立即执行的节流？

## EventLoop

### EventLoop 事件循环？

<Card>
JS 是单线程运行的，当遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。

当一个异步事件返回结果后，JS 会将这个事件加入与当前执行栈不同的另一个队列——**事件队列（Task Queue）**。

被放入事件队列不会立即执行其回调，而是等待当前执行栈中所有任务都执行完毕，主程序处于闲置状态时，主线程会去查找事件队列中是否有任务。

如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环，这个过程被称为**事件循环（Event Loop）**。

**异步任务分类**：

实际上，异步任务之间并不相同，他们的执行优先级也有区别。异步任务分两类：**微任务（micro task）**和**宏任务（macro task）**。

- **微任务（Microtask）**：
  - `Promise` 的回调
  - `MutationObserver`
  - `queueMicrotask()`
  - Node.js 中的 `process.nextTick`

- **宏任务（Macrotask）**：
  - `script` 脚本的执行
  - `setTimeout`、`setInterval`
  - `setImmediate`（Node.js）
  - I/O 操作
  - UI 渲染

**执行顺序**：
1. 执行同步代码
2. 执行所有微任务
3. 执行一个宏任务
4. 执行所有微任务
5. 执行下一个宏任务
6. 如此循环

**重要**：
- 在当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件
- 然后再去宏任务队列中取出一个事件
- 同一次事件循环中，微任务永远在宏任务之前执行

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- Event Loop 的执行顺序
- 微任务和宏任务的区别
- Node.js 和浏览器环境下的 Event Loop 区别
</Card>

推荐阅读：
- [详解 JavaScript 中的 Event Loop（事件循环）机制](https://zhuanlan.zhihu.com/p/33058983)
- [微任务、宏任务与 Event-Loop](https://juejin.cn/post/6844903657264136200)

## Promise

### Promise？

`Promise` 是异步编程的一种解决方案。

- `Promise` 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例
- 一个 Promise 实例有三种状态：
  - `pending`（初始状态）
  - `fulfilled`（成功的操作）
  - `rejected`（失败的操作）
- 状态只能由 `pending` 转变 `fulfilled` 或者 `rejected` 状态
- 状态一经改变，就无法再改变了
- 状态的改变是通过 `resolve()` 和 `reject()` 函数来实现的
- 可以在异步操作结束后调用这两个函数改变 Promise 实例的状态
- Promise 的原型上定义了一个 `then()` 方法
- 使用这个 then 方法可以为两个状态的改变注册回调函数
- 这个回调函数属于微任务，会在本轮事件循环的末尾执行

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- Promise 的状态机
- Promise 的链式调用
- Promise.all、Promise.race、Promise.allSettled、Promise.any 的区别
- 如何手写一个 Promise？
- 如何实现 Promise 的并发控制？

推荐阅读：
- [Promise 对象](https://es6.ruanyifeng.com/#docs/promise)
- [Promise 不会？看这里！！！史上最通俗易懂的 Promise！！！](https://juejin.cn/post/6844903607968481287)
- [100 行代码实现 Promises/A+规范](https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g)

## ES6+ 新特性

### Array.from() 和 Array.of() 的使用及区别？

- **`Array.from()`**：
  - 将伪数组对象或可遍历对象转换为真数组
  - 接受三个参数：input、map、context
  - input：待转换的伪数组对象或可遍历对象
  - map：类似于数组的 map 方法，用来对每个元素进行处理
  - context：绑定 map 中用到的 this

- **`Array.of()`**：
  - 将一系列值转换成数组
  - 会创建一个包含所有传入参数的数组
  - 不管参数的数量与类型
  - 解决了 `new Array()` 行为不统一的问题

### ES6 新增特性

1. **变量声明**：
   - `let`：块级作用域变量
   - `const`：块级作用域常量

2. **解构赋值**：
   - 数组解构
   - 对象解构

3. **模板字符串**：
   - 使用反引号
   - 支持多行字符串
   - 支持变量插值

4. **箭头函数**：
   - 简化函数定义
   - 不绑定 `this`

5. **扩展运算符**：
   - 数组扩展：`[...arr]`
   - 对象扩展：`{...obj}`

6. **Promise**：
   - 异步编程解决方案

7. **Class 类**：
   - 面向对象编程

8. **Module 模块**：
   - `import`、`export`

9. **Symbol**：
   - 唯一标识符

10. **Proxy**：
    - 代理对象

11. **Reflect**：
    - 反射对象

12. **Map、Set**：
    - 新的数据结构

13. **Generator**：
    - 生成器函数

14. **Async/Await**：
    - 异步函数

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- ES6+ 新特性的应用场景
- `let` 和 `const` 的区别
- 模块化的实现原理

## 函数式编程

### 函数式编程概念？

**核心概念**：
- **纯函数**：相同的输入永远得到相同的输出，没有副作用
- **高阶函数**：接收函数作为参数或返回函数的函数
- **函数组合**：将多个函数组合成一个函数
- **不可变性**：数据不可变
- **柯里化**：将多参数函数转换为单参数函数

**常用方法**：
- `map`：映射
- `filter`：过滤
- `reduce`：归约
- `forEach`：遍历
- `find`、`findIndex`：查找
- `some`、`every`：判断

**2025年高频考点**：
<Label color="purple">高频考点</Label>
- 函数式编程的优势
- 如何实现一个柯里化函数？
- 函数组合的应用

---

**参考链接：**
- [连八股文都不懂还指望在前端混下去么](https://juejin.cn/post/7016593221815910408)
- [做了一份前端面试复习计划，保熟~](https://juejin.cn/post/7061588533214969892)
- [2023 前端面试系列-- JS 篇](https://juejin.cn/post/7176644710847479869)
- [JavaScript 深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)
- [轻松理解 JS 原型和原型链](https://juejin.cn/post/6844903989088092174)
- [详解 JavaScript 中的 Event Loop（事件循环）机制](https://zhuanlan.zhihu.com/p/33058983)
- [微任务、宏任务与 Event-Loop](https://juejin.cn/post/6844903657264136200)
- [Promise 对象](https://es6.ruanyifeng.com/#docs/promise)
- [Promise 不会？看这里！！！史上最通俗易懂的 Promise！！！](https://juejin.cn/post/6844903607968481287)