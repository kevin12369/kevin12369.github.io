---
language: 'zh-CN'
title: '数据结构与算法07-排序算法'
description: '排序算法是算法学习的基础，掌握排序算法对理解算法思想至关重要。本文详解各种排序算法的原理和实现。'
publishDate: '2024-01-01'
tags: ['数据结构', '算法', '排序', '快速排序', '归并排序']
---

import { Card, Label, Collapse, Aside } from 'astro-pure/user'

> 排序算法是算法学习的基础，掌握排序算法对理解算法思想至关重要

## 前言

排序是将一组数据按照特定顺序排列的过程，是计算机科学中最基础也是最重要的算法之一。

**核心应用**：
- **数据处理**：数据清洗、数据分析
- **搜索优化**：二分查找的前提
- **算法基础**：很多高级算法的基础步骤

在本文中，我们将深入探讨：
1. 排序算法的基本概念和评价指标
2. 常见排序算法的原理和实现
3. 排序算法的复杂度分析
4. 2025年高频面试题

## 排序算法基础

### 评价指标

#### 1. 时间复杂度

衡量排序算法执行时间随数据规模增长的变化

| 复杂度 | 说明 | 示例 |
|--------|------|------|
| O(n²) | 平方级，数据量大时效率低 | 冒泡、选择、插入排序 |
| O(n log n) | 对数线性级，效率较高 | 快速、归并、堆排序 |
| O(n) | 线性级，效率最高 | 计数、桶、基数排序 |

#### 2. 空间复杂度

衡量排序算法所需额外空间

| 复杂度 | 说明 | 示例 |
|--------|------|------|
| O(1) | 原地排序，不需要额外空间 | 冒泡、选择、插入排序 |
| O(n) | 需要额外空间存储数据 | 归并排序 |
| O(log n) | 递归栈空间 | 快速排序 |

#### 3. 稳定性

相同元素的相对顺序在排序后是否保持不变

<Label>稳定排序</Label>

**稳定排序**：冒泡、插入、归并、基数排序
**不稳定排序**：选择、快速、堆排序

### 排序算法分类

#### 按稳定性分类
- **稳定排序**：保持相等元素的相对顺序
- **不稳定排序**：可能改变相等元素的相对顺序

#### 按时间复杂度分类
- **O(n²)排序**：冒泡、选择、插入排序
- **O(n log n)排序**：快速、归并、堆排序
- **O(n)排序**：计数、桶、基数排序（特定条件）

#### 按是否原地排序分类
- **原地排序**：只使用常数额外空间
- **非原地排序**：需要O(n)额外空间

## 基础排序算法

### 1. 冒泡排序

**原理**：重复遍历数组，比较相邻元素，若顺序错误则交换，直到没有需要交换的元素

**图示**：
```
初始: [5, 3, 8, 4, 2]
第一轮: [3, 5, 4, 2, 8]  ← 8冒泡到末尾
第二轮: [3, 4, 2, 5, 8]  ← 5冒泡到倒数第二
第三轮: [3, 2, 4, 5, 8]  ← 4冒泡到倒数第三
第四轮: [2, 3, 4, 5, 8]  ← 完成
```

**代码实现**：
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # 优化：如果本轮没有交换，说明已排序
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr
```

**复杂度分析**：
- 时间复杂度：O(n²) - 最坏和平均情况
- 空间复杂度：O(1) - 原地排序
- 稳定性：稳定

### 2. 选择排序

**原理**：每次从未排序部分选择最小元素，放到已排序部分的末尾

**图示**：
```
初始: [5, 3, 8, 4, 2]
第一轮: [2, 5, 8, 4, 3]  ← 选择2，与5交换
第二轮: [2, 3, 8, 4, 5]  ← 选择3，与5交换
第三轮: [2, 3, 4, 8, 5]  ← 选择4，与8交换
第四轮: [2, 3, 4, 5, 8]  ← 选择5，与8交换
```

**代码实现**：
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        # 找到未排序部分的最小元素
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # 交换
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
```

**复杂度分析**：
- 时间复杂度：O(n²) - 无论什么情况都需要比较n²/2次
- 空间复杂度：O(1) - 原地排序
- 稳定性：不稳定

### 3. 插入排序

**原理**：将未排序元素插入到已排序部分的正确位置

**图示**：
```
初始: [5, 3, 8, 4, 2]
第一轮: [3, 5, 8, 4, 2]  ← 插入3
第二轮: [3, 5, 8, 4, 2]  ← 插入8
第三轮: [3, 4, 5, 8, 2]  ← 插入4
第四轮: [2, 3, 4, 5, 8]  ← 插入2
```

**代码实现**：
```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # 将大于key的元素向后移动
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

**复杂度分析**：
- 时间复杂度：O(n²) - 最坏和平均情况，O(n) - 最好情况（已排序）
- 空间复杂度：O(1) - 原地排序
- 稳定性：稳定

## 高级排序算法

### 4. 快速排序

**原理**：选择一个基准元素，将数组分为两部分，小于基准的放左边，大于基准的放右边，递归排序

**图示**：
```
初始: [5, 3, 8, 4, 2]
选择5作为基准:
[3, 4, 2] < 5 < [8]
递归排序左部分:
[2, 3, 4]
递归排序右部分:
[8]
合并: [2, 3, 4, 5, 8]
```

**代码实现**：
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)
```

**原地实现**：
```python
def quick_sort_inplace(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1

    if low < high:
        # 分区
        pivot_index = partition(arr, low, high)
        # 递归排序
        quick_sort_inplace(arr, low, pivot_index - 1)
        quick_sort_inplace(arr, pivot_index + 1, high)

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1

    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
```

**复杂度分析**：
- 时间复杂度：O(n log n) - 平均情况，O(n²) - 最坏情况（已排序）
- 空间复杂度：O(log n) - 递归栈空间
- 稳定性：不稳定

### 5. 归并排序

**原理**：将数组分成两半，递归排序每半，然后合并两个有序数组

**图示**：
```
初始: [5, 3, 8, 4, 2]
分: [5, 3, 8] 和 [4, 2]
分: [5, 3] 和 [8] 和 [4, 2]
分: [5] 和 [3] 和 [8] 和 [4] 和 [2]
合: [3, 5] 和 [8] 和 [2, 4]
合: [3, 5, 8] 和 [2, 4]
合: [2, 3, 4, 5, 8]
```

**代码实现**：
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

**复杂度分析**：
- 时间复杂度：O(n log n) - 无论什么情况
- 空间复杂度：O(n) - 需要额外空间
- 稳定性：稳定

### 6. 堆排序

**原理**：利用堆这种数据结构，将数组构建成最大堆，然后依次取出堆顶元素

**图示**：
```
初始: [5, 3, 8, 4, 2]
构建最大堆: [8, 4, 5, 3, 2]
取出8: [5, 4, 2, 3]
重新堆化: [5, 4, 2, 3]
取出5: [4, 3, 2]
重新堆化: [4, 3, 2]
取出4: [3, 2]
重新堆化: [3, 2]
取出3: [2]
取出2: []
结果: [2, 3, 4, 5, 8]
```

**代码实现**：
```python
def heap_sort(arr):
    n = len(arr)

    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 逐个取出堆顶元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

    return arr

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

**复杂度分析**：
- 时间复杂度：O(n log n) - 无论什么情况
- 空间复杂度：O(1) - 原地排序
- 稳定性：不稳定

## 特殊排序算法

### 7. 计数排序

**原理**：统计每个元素出现的次数，然后根据计数结果输出有序数组

**适用条件**：元素范围有限且较小

**代码实现**：
```python
def counting_sort(arr):
    if not arr:
        return arr

    # 找到最大值和最小值
    max_val = max(arr)
    min_val = min(arr)

    # 创建计数数组
    count = [0] * (max_val - min_val + 1)

    # 统计每个元素出现的次数
    for num in arr:
        count[num - min_val] += 1

    # 重建有序数组
    result = []
    for i in range(len(count)):
        result.extend([i + min_val] * count[i])

    return result
```

**复杂度分析**：
- 时间复杂度：O(n + k) - k为元素范围
- 空间复杂度：O(k)
- 稳定性：稳定

### 8. 桶排序

**原理**：将元素分配到多个桶中，每个桶单独排序，然后合并

**适用条件**：元素分布均匀

**代码实现**：
```python
def bucket_sort(arr, bucket_size=5):
    if not arr:
        return arr

    # 找到最大值和最小值
    max_val = max(arr)
    min_val = min(arr)

    # 计算桶的数量
    bucket_count = (max_val - min_val) // bucket_size + 1
    buckets = [[] for _ in range(bucket_count)]

    # 将元素分配到桶中
    for num in arr:
        bucket_index = (num - min_val) // bucket_size
        buckets[bucket_index].append(num)

    # 对每个桶进行排序
    for bucket in buckets:
        bucket.sort()

    # 合并所有桶
    result = []
    for bucket in buckets:
        result.extend(bucket)

    return result
```

**复杂度分析**：
- 时间复杂度：O(n + k) - 平均情况
- 空间复杂度：O(n + k)
- 稳定性：稳定

### 9. 基数排序

**原理**：按照元素的每一位进行排序，从最低位到最高位

**适用条件**：元素可以分解为多个关键字

**代码实现**：
```python
def radix_sort(arr):
    if not arr:
        return arr

    # 找到最大值
    max_val = max(arr)

    # 按照每一位进行排序
    exp = 1
    while max_val // exp > 0:
        counting_sort_by_digit(arr, exp)
        exp *= 10

    return arr

def counting_sort_by_digit(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    # 统计当前位出现的次数
    for i in range(n):
        index = (arr[i] // exp) % 10
        count[index] += 1

    # 计算累积计数
    for i in range(1, 10):
        count[i] += count[i - 1]

    # 构建输出数组
    for i in range(n - 1, -1, -1):
        index = (arr[i] // exp) % 10
        output[count[index] - 1] = arr[i]
        count[index] -= 1

    # 复制回原数组
    for i in range(n):
        arr[i] = output[i]
```

**复杂度分析**：
- 时间复杂度：O(d * n) - d为数字位数
- 空间复杂度：O(n + k)
- 稳定性：稳定

## 排序算法对比

| 算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 稳定性 | 适用场景 |
|------|----------------|----------------|-----------|--------|---------|
| 冒泡排序 | O(n²) | O(n²) | O(1) | 稳定 | 数据量小，基本有序 |
| 选择排序 | O(n²) | O(n²) | O(1) | 不稳定 | 数据量小，交换成本高 |
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 数据量小，基本有序 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 数据量大，随机分布 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 数据量大，要求稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 数据量大，内存有限 |
| 计数排序 | O(n + k) | O(n + k) | O(k) | 稳定 | 元素范围小 |
| 桶排序 | O(n + k) | O(n²) | O(n + k) | 稳定 | 元素分布均匀 |
| 基数排序 | O(d * n) | O(d * n) | O(n + k) | 稳定 | 元素可分解为关键字 |

## 高频面试题

### 题目1：颜色分类

**题目描述**：
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

**示例**：
```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

#### 解题思路

**方法**：三指针法

使用三个指针：
- left：指向红色的边界
- current：当前遍历的指针
- right：指向蓝色的边界

#### 代码实现

**Python**：
```python
def sortColors(nums):
    left, current, right = 0, 0, len(nums) - 1

    while current <= right:
        if nums[current] == 0:
            nums[left], nums[current] = nums[current], nums[left]
            left += 1
            current += 1
        elif nums[current] == 1:
            current += 1
        else:  # nums[current] == 2
            nums[current], nums[right] = nums[right], nums[current]
            right -= 1
```

#### 复杂度分析
- **时间复杂度**：O(n) - 一次遍历
- **空间复杂度**：O(1) - 原地排序

### 题目2：最大数

**题目描述**：
给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**示例**：
```
输入：nums = [10,2]
输出："210"

输入：nums = [3,30,34,5,9]
输出："9534330"
```

#### 解题思路

**方法**：自定义排序

1. 将数字转换为字符串
2. 自定义排序规则：a + b > b + a
3. 拼接结果

#### 代码实现

**Python**：
```python
from functools import cmp_to_key

def largestNumber(nums):
    # 转换为字符串
    nums_str = list(map(str, nums))

    # 自定义排序
    def compare(a, b):
        if a + b > b + a:
            return -1
        elif a + b < b + a:
            return 1
        else:
            return 0

    nums_str.sort(key=cmp_to_key(compare))

    # 处理前导零
    result = ''.join(nums_str)
    return '0' if result[0] == '0' else result
```

#### 复杂度分析
- **时间复杂度**：O(n log n * k) - k为平均数字长度
- **空间复杂度**：O(n)

### 题目3：合并区间

**题目描述**：
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [start_i, end_i] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组。

**示例**：
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

#### 解题思路

**方法**：排序 + 合并

1. 按区间起点排序
2. 遍历区间，合并重叠区间

#### 代码实现

**Python**：
```python
def merge(intervals):
    if not intervals:
        return []

    # 按起点排序
    intervals.sort(key=lambda x: x[0])

    merged = [intervals[0]]

    for interval in intervals[1:]:
        last = merged[-1]

        # 如果重叠，合并
        if interval[0] <= last[1]:
            last[1] = max(last[1], interval[1])
        else:
            merged.append(interval)

    return merged
```

#### 复杂度分析
- **时间复杂度**：O(n log n) - 排序
- **空间复杂度**：O(log n) - 排序栈空间

## 实际应用

### 1. 数据库索引

```python
# B+树索引使用排序
class BPlusTreeIndex:
    def __init__(self):
        self.root = None

    def insert(self, key, value):
        # 插入时保持有序
        pass

    def search(self, key):
        # 利用有序性快速查找
        pass
```

### 2. 排行榜系统

```python
class Leaderboard:
    def __init__(self):
        self.scores = []

    def add_score(self, player_id, score):
        self.scores.append((player_id, score))
        # 使用快速排序
        quick_sort(self.scores, key=lambda x: x[1], reverse=True)

    def get_top_k(self, k):
        return self.scores[:k]
```

### 3. 文件管理

```python
class FileManager:
    def sort_files(self, files, criterion='name'):
        if criterion == 'name':
            return sorted(files, key=lambda x: x['name'])
        elif criterion == 'size':
            return sorted(files, key=lambda x: x['size'])
        elif criterion == 'date':
            return sorted(files, key=lambda x: x['date'])
```

## 常见陷阱

### 1. 边界条件

**常见错误**：
```python
# 错误：未处理空数组
def sort(arr):
    return quick_sort(arr)  # arr可能为空
```

**正确做法**：
```python
def sort(arr):
    if not arr:
        return []
    return quick_sort(arr)
```

### 2. 稳定性问题

**常见错误**：
```python
# 错误：使用不稳定排序导致相同元素顺序改变
arr = [(1, 'a'), (2, 'b'), (1, 'c')]
quick_sort(arr, key=lambda x: x[0])  # (1, 'a')和(1, 'c')的顺序可能改变
```

**正确做法**：
```python
# 使用稳定排序
arr = [(1, 'a'), (2, 'b'), (1, 'c')]
merge_sort(arr, key=lambda x: x[0])  # 保持(1, 'a')在(1, 'c')之前
```

## 2025年面试趋势

### 1. 综合考察

**趋势**：
- 排序 + 查找
- 排序 + 动态规划
- 排序 + 贪心算法

### 2. 实际场景

**趋势**：
- 大数据排序
- 分布式排序
- 实时排序

### 3. 优化技巧

**趋势**：
- 并行排序
- 外部排序
- 混合排序

## 总结

排序算法是算法学习的基础，掌握排序算法的关键在于：

1. **理解算法原理**：清楚每种排序算法的工作方式
2. **掌握复杂度分析**：能够分析时间和空间复杂度
3. **了解稳定性**：知道哪些算法是稳定的
4. **选择合适算法**：根据数据特点选择合适的排序算法
5. **注意边界条件**：处理空数组、单元素数组等情况

**学习建议**：
- 多画图理解排序过程
- 练习不同排序算法的实现
- 掌握复杂度分析方法
- 了解实际应用场景

<Card>
**下一步**：让我们继续学习查找算法，掌握高效数据检索的技巧。
</Card>

---

**参考资料**：
- LeetCode：https://leetcode.cn/
- 《算法（第4版）》
- 《算法导论》